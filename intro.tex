\section*{Введение}
Формальные языки с зависимыми типами могут быть использованы для доказательств свойств кода программы. Также возможно ввести типы, аналогичные сущностям области математики, в которой мы хотим доказывать теоремы и просто писать термы, таким образом предъявляя доказательства утверждений. Плюс данного подхода заключается в том, что проверка доказательств перекладывается на алгоритм проверки типов --- во многих случаях автоматизированный процесс.

Однако может возникнуть ситуация, что конструкции, которыми мы хотим пользоваться, не существуют в языке программирования. Поэтому, если мы хотим переложить верификацию наших высказываний на алгоритм проверки типов, приходится писать свой язык программирования и уже в нем доказывать утверждения.

Решение описанной проблемы --- генерация зависимых языков по спецификации конструкций, которые мы хотим от нашего языка, является темой данной работы.

\hfill

Зависимые языки состоят из конструкций языка и их семантика задается с помощью правил вывода и редукций. В работе использована "типизация" конструкций\footnote{Это сделано ещё и потому, что работа основана на~\cite{isaev}. В статье предложено описано языков в качестве существенно лгебраических теорий. У специфицируемого языка есть сигнатура и аксиомы, что транслируется в типизироанные конструкции и правила вывода и редукции.}, так же как и в~\cite{twelf}.

В спецификация задаются метатипы метапеременных (сорта) и конструкций, сами конструкции, правила вывода каждой конструкции и редукции языка. Всегда есть сорт зависимых термов и сорт (зависимых) типов. Например STLC\cite{stlc} будет задан так:

\begin{lstlisting}[frame=single]
Dependent sorts:
  tm
SimpleSorts:
  ty
FunctionalSymbols:
  lam: (ty, 0)*(tm, 1) -> tm
  app: (ty, 0)*(tm, 0)*(tm, 0) -> tm
  arrow: (ty, 0)*(ty, 0) -> ty
Axioms:
  TAbs =
    forall S : ty , T : ty , x.t : tm
      x : S |- t : T |--- |- lam(S , x.t) : arrow(S, T)
  TApp =
    forall t1 : tm , t2 : tm , S : ty, x.T : ty
      |- t1 : arrow(S, T), |- t2 : S
      |------------------------------
      |- app(T, t1 , t2) : T
  IArrow =
    forall T1 : ty , T2 : ty
      |--- |- arrow(T1, T2) def
Reductions:
  Beta =
    forall x.b : tm, A : ty, a : tm, T : ty
       |--- |- app(T, lam(A, x.b), a) => b[x := a]
\end{lstlisting}

Также можно задать с-стабильность правил вывода относительно замкнутых типов, что означает, что данная аксиома применима только в случае наличия свободных переменных только специфицированных типов. Например, если мы хотим, чтобы лямбду можно было применять только, если все свободные переменные внутри неё имеют тип Bool или стрелок из Bool в Bool, мы аннотируем наше правило вывода типом Bool:
\begin{lstlisting}[frame=single]
FunctionalSymbols:
  lam: (ty, 0)*(tm, 1) -> tm
  app: (ty, 0)*(tm, 0)*(tm, 0) -> tm
  arrow: (ty, 0)*(ty, 0) -> ty
  bool: ty
Axioms:
  IBool =
    |--- |- Bool def
  [bool, arrow(bool, bool)]
  TAbs =
    forall S : ty , T : ty , x.t : tm
      x : S |- t : T |--- |- lam(S , x.t) : arrow(S, T)
\end{lstlisting}

Конечно у нас появится новая конструкция и правило вывода соответствующая нашему новоиспеченному типу. Ещё вероятно мы захотим его населить и т.д.

\hfill

После проверок спецификации (описанных в Секции~\ref{constraints}) строится структура хранящая информацию о правилах вывода, редукциях и конструкциях языка. С её помощью происходит кодогенерация представления термов языка и функций проверки типов и нормализации.

Было выбрано представление структур данных в виде индексов де Брейна через полиморфную рекурсию (подробнее в Секции~\ref{de_brujin_impl}). Само представление де Брейна имеет ряд преимуществ: альфа-эквивалентность превращается в проверку на равенство и нет проблем с избеганием захвата переменных (подробнее в Секции\ref{de_brujin}).

Использование полиморфной рекурсии для выражения индексов де Брейна имеет дополнительные преимущества:
\begin{itemize}
  \item Проверка корректности построения термов на уровне типов (нельзя писать Lam 123, тк лямбда захватывает только одну переменную).
  \item Можно абстрагировать это представление, превратив Scope в трансформер монад. Тогда нам остается лишь определить представителя класса Monad для нашего представления термов (работает как подстановка), что делается комически просто.
  \item Абстрагирование представления дает нам функции abstract и instantiate, которые абстрагируют переменную и инстанциируют самую внешнюю связную переменную соответственно.
  \item С помощью механизма Deriving Haskell можно получить представителя классов Functor, Traversable и Foldable. Что дает нам функции toList --- список свободных переменных терма и traverse --- применить аппликативную функцию к переменным терма.
  \item Можно определить обобщенные Show и Eq --- не теряем простоты более простого представления.
\end{itemize}

\begin{lstlisting}[caption={Представление STLC и представитель класса Monad},captionpos=b, frame=single]
data Term a = Var a
            | TyDef
            | App (Type a) (Term a) (Term a)
            | Lam (Type a) (Scope Term a)
            | Arrow (Type a) (Type a)

instance Monad Term where
      Var v1 >>= f = f v1
      TyDef >>= f = TyDef
      App v1 v2 v3 >>= f = App (v1 >>= f) (v2 >>= f) (v3 >>= f)
      Lam v1 v2 >>= f = Lam (v1 >>= f) (v2 >>>= f)
      Arrow v1 v2 >>= f = Arrow (v1 >>= f) (v2 >>= f)
\end{lstlisting}

Затем происходит генерация функций infer и nf, так как остальные функции --- проверки типа терма, печати терма, функции управления контекстами --- не зависят от специфицируемого языка.

Функция nf сопоставляет терм с образцом, сгенерированном для каждой левой части редукции. Если происходит совпадение --- строит правую часть совпавшей редукции. Если нет совпадения то возвращает конструкцию, которую приняла, предварительно применив себя же ко всем внутренним термам.

Функция infer сопоставляет терм с образцом, наличие правил вывода для всех конструкций гарантирует совпадение хоть с одним образцом. Затем проверяет каждую предпосылку отдельно и возвращает тип терма, который ей был передан, в соответствии с правилом вывода конструкции (если терм переданный не является представителем сорта термов возвращается аналог кайнда * для данного сорта).

Для построения правой части мы должны уметь строить термы из имеющихся у нас метапеременных, это описано в деталях в Секции~\ref{build_exp}.

Затем используется библиотека Haskell.src.exts\cite{src_exts} для замены структур данных и функций заглушек в написанном от руки модуле LangTemplate.

Полученный код компилируется Haskell и на нем можно описывать термы специфицированного языка, его контекст и выводить тип терма или приводить его в нормальную форму.


%%








%%
