\section*{Введение}
Формальные языки с зависимыми типами могут быть использованы для доказательств свойств кода программы. Также в языке с зависимыми возможно определить типы, аналогичные сущностям области математики, в которой мы хотим доказывать теоремы и просто писать термы, таким образом предъявляя доказательства утверждений. Это называется соответствием Карри-Говарда-Ламбека\cite{curry_how}. Достоинство данного подхода заключается в том, что проверка доказательств перекладывается на алгоритм проверки типов соответсвующего языка --- во многих случаях автоматизированный процесс.

Наиболее известными примерами языков, которые пользуются соответствием Карри-Говарда для доказательства математических утверждений являются Coq\cite{coq} и Agda\cite{agda}. Например, доказательство теоремы о четырех красках было завершено в 2005 году с помощью Coq\cite{weisstein2002four}.
Пример относительно простого доказательства корректности функции filter на Agda приведен в Приложении~\ref{sort_proof}.

\hfill

В процессе формализации теории может возникнуть ситуация, что конструкции, которыми мы хотим пользоваться, не существуют в языке программирования. Поэтому, если мы хотим переложить верификацию наших высказываний на алгоритм проверки типов соответствующего языка с зависимыми типами, приходится писать свой язык программирования и уже в нем доказывать утверждения.

В дальнейшем мы понимаем вычисление как переписывание термов согласно редукциям языка, пока не получим терм к которому ни одна редукция неприменима --- этот процесс называется приведением терма в \textit{нормальную форму}. Так как типы зависимого языка могут включать в себя произвольные термы, проверка типов является задачей тесно связанной с вычислением языка. Поэтому написание функции проверки типов языка становится достаточно ёмкой задачей.

Однако общий алгоритм проверки типов не сильно отличается от языка к языку, таким образом его можно генерировать по спецификации. В работе описан способ спецификации языков, с последующей генерацией модуля Haskell\cite{haskell} для работы со специфицированным языком, в котором есть функции проверки типов, нормализации, равенства термов, работы с контекстами и стандартных операций над термами (такие как подстановка, абстракция и работа под связыванием).

\hfill

Все зависимые языки состоят из некоторых конструкций. Например, язык булевых выражений Bool состоит из 4 конструкций: тип Bool, константы true и false, и конструкция if-then-else. Нас интересуют только типизированные языки, поэтому для каждой конструкции должны быть прописаны правила типизации. В нашем языке true имеет тип Bool, false имеет тип Bool, if-then-else принимает четыре аргумента --- выражение типа Bool, тип возвращаемого выражения и два выражения, имеющих тип равный возвращаемому. Формально языки задаются через правила вывода(см. Секцию~\ref{lang_spec}).

Также необходимо задавать правила вычисления языка. Для Bool их всего два, а именно для конструкции if-then-else мы возвращаем либо ветку then, либо ветку else в зависимости от первого её аргумента.

Выше был представлен пример обычного, независимого языка Bool. Чтобы из него сделать зависимый язык Bool, нужно модифицировать конструкцию if-then-else. Теперь вторым её аргументом будет функция, возвращающая тип возвращаемого выражения в зависимости от переданного ей аргумента типа Bool. Тогда станет возможной конструкция вида: if-then-else(t, f, True, 1), которая будет возвращать либо True типа Bool, либо 1 типа Int в зависимости от первого аргумента конструкции. Подробнее об этом написано в~\cite{martin_lof}.

\hfill

Наша цель научиться записывать правила типизации формально и по такому описанию генерировать код, который бы осуществлял проверку типов для соответствующего языка.

Формализация языка происходит путем описания его спецификации. В спецификации задаются возможные виды высказываний языка (термы, типы), его конструкции, с описанием видов аргументов и возвращаемого выражения. Также описываются правила вывода каждой конструкции и правила редукции языка.

Также спецификация позволяет задать с-стабильность правил вывода относительно замкнутых типов, что означает, что данная конструкция применима только в случае наличия свободных переменных только указанных типов. Например, если мы хотим, чтобы конструкцию if-then-else можно было применять только, если все свободные переменные внутри неё имеют тип Bool или являются функциями из Bool в Bool, мы можем проаннотировать соответствующее правило вывода списком $[Bool, Bool\rightarrow Bool]$.

После проверок спецификации (описанных в Секции~\ref{constraints}) строится структура хранящая информацию о правилах вывода, редукциях и конструкциях языка. С её помощью происходит кодогенерация представления термов языка и функций проверки типов и нормализации.

Для работы со специфицированным языком генерируется структура, представляющая термы в языке. Существует несколько вариантов представления (см. Секцию~\ref{term_repr} для подробного обсуждения этих вариантов):
\begin{enumerate}
\item Обычное именованное (переменные представляются в виде строк)
\item Обычные индексы де Брейна\cite{de_brujin} (переменные явяются целыми числами, указывающими на место их связывания)
\item Индексы де Брейна с использованием полиморфной рекурсии\cite{poly_rec}
\end{enumerate}

У первых двух способов представления есть недостатки. В первом необходимо вводить $\alpha$-эквивалентность на термах --- \textit{$\alpha$-эквивалентными} называются термы, которые отличаются только в именовании связанных переменных. Во втором варианте возникают сложности с работой под связываниями переменных. В каждом из этих случаев легко допустить ошибку при работе с термами. Третий вариант является модификацией второго, в которой допустить ошибку при работе с индексами сложнее из-за проверок на уровне типов, таким образом код получается более безопасным.

Также генерирутся функции для нормализации, сравнения и проверки типов термов. Сравнение используется при проверке типов, а нормализация в сравнении (подробнее в Секции~\ref{typecheck}).

Нормализация генерируется по правилам редукции, описанным в спецификации, функция проверки типов --- по правилам вывода. Как мы и отмечали, неявно подразумевается, что в языке есть отношение эквивалентности на термах, которое порождается отношением редукции. Это выражается в том, что сравнение термов (которое сравнивает их с точностью до этого отношения эквивалетности) сначала нормализует термы, а потом сравнивает их нормальные формы.



%%








%%
