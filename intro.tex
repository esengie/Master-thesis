\section*{Введение}
Формальные языки с зависимыми типами могут быть использованы для доказательств свойств кода программы. Также возможно ввести типы, аналогичные сущностям области математики, в которой мы хотим доказывать теоремы и просто писать термы, таким образом предъявляя доказательства утверждений. Это называется соответствием Карии-Говарда-Ламбека\cite{curry_how}. Достоинство данного подхода заключается в том, что проверка доказательств перекладывается на алгоритм проверки типов --- во многих случаях автоматизированный процесс.

Наиболее известными примерами языков которые пользуются соответствием Карри-Говарда для доказательства математических утверждений являются Coq\cite{coq} и Agda\cite{agda}. Например доказательство известной теоремы четырех красок было завершено в 2005 году с помощью Coq\cite{weisstein2002four}.
Пример относительно простого доказательства на Agda приведен в Приложении~\ref{sort_proof}.

Однако может возникнуть ситуация, что конструкции, которыми мы хотим пользоваться, не существуют в языке программирования. Поэтому, если мы хотим переложить верификацию наших высказываний на алгоритм проверки типов, приходится писать свой язык программирования и уже в нем доказывать утверждения.

Так как типы могут включать в себя произвольные термы языка, проверка типов становится задачей тесно связанной с вычислением языка\footnote{В дальнейшем мы понимаем вычисление как переписывание термов согласно редукциям, пока не получим терм к которому ни одна редукция неприменима --- этот процесс называется приведением терма в \textit{нормальную форму}.}. Поэтому написание функции проверки типов языка становится достаточно ёмкой задачей. В работе описан способ генерации библиотеки Haskell\cite{haskell} для работы со специфицированным языком.

\hfill

Зависимые языки состоят из конструкций языка и их семантика задается с помощью правил вывода и редукций. В работе использована ``типизация'' конструкций\footnote{Это сделано ещё и потому, что работа основана на~\cite{isaev}. В статье предложено описано языков в качестве существенно алгебраических теорий. У специфицируемого языка есть сигнатура и аксиомы, что транслируется в типизированные конструкции, правила вывода и редукции.}, так же как и в~\cite{twelf}.

В спецификация задаются метатипы метапеременных (сорта) и конструкций, сами конструкции, правила вывода каждой конструкции и редукции языка. Всегда существует сорт зависимых термов и сорт (зависимых) типов. Во вставке кода~\ref{lst_stlc} приведена спецификация STLC\cite{stlc}. Нотация (x y).T означает, что контекст данной переменной содержит ещё две переменных в дополнение к существующему.

\begin{lstlisting}[label={lst_stlc}, caption={Описание STLC при помощи языка специфкации},captionpos=b, frame=single, float, floatplacement=H]
Dependent sorts:
  tm
SimpleSorts:
  ty
FunctionalSymbols:
  lam: (ty, 0)*(tm, 1) -> tm
  app: (ty, 0)*(tm, 0)*(tm, 0) -> tm
  arrow: (ty, 0)*(ty, 0) -> ty
Axioms:
  TAbs =
    forall S : ty , T : ty , x.t : tm
      x : S |- t : T |--- |- lam(S , x.t) : arrow(S, T)
  TApp =
    forall t1 : tm , t2 : tm , S : ty, x.T : ty
      |- t1 : arrow(S, T), |- t2 : S
      |------------------------------
      |- app(T, t1 , t2) : T
  IArrow =
    forall T1 : ty , T2 : ty
      |--- |- arrow(T1, T2) def
Reductions:
  Beta =
    forall x.b : tm, A : ty, a : tm, T : ty
       |--- |- app(T, lam(A, x.b), a) => b[x := a]
\end{lstlisting}

Также спецификация позволяет задать с-стабильность правил вывода относительно замкнутых типов, что означает, что данная аксиома применима только в случае наличия свободных переменных только указанных типов. Например, если мы хотим, чтобы лямбда-абстракцию можно было применять только, если все свободные переменные внутри неё имеют тип Bool или морфизмов из Bool в Bool, мы аннотируем наше правило вывода типом Bool, как показано во вставке~\ref{lst_add_bool}.

\begin{lstlisting}[label={lst_add_bool}, caption={Пример спецификации того, что конструкция $\lambda$ должна быть стабильна относительно типа Bool и Bool $\rightarrow$ Bool},captionpos=b, frame=single, float, floatplacement=H]
FunctionalSymbols:
  lam: (ty, 0)*(tm, 1) -> tm
  app: (ty, 0)*(tm, 0)*(tm, 0) -> tm
  arrow: (ty, 0)*(ty, 0) -> ty
  bool: ty
Axioms:
  IBool =
    |--- |- Bool def
  [bool, arrow(bool, bool)]
  TAbs =
    forall S : ty , T : ty , x.t : tm
      x : S |- t : T |--- |- lam(S , x.t) : arrow(S, T)
\end{lstlisting}

Конечно у нас появится новая конструкция и правило вывода соответствующая нашему новоиспеченному типу. Ещё, вероятно, мы захотим чтобы тип имел представителей False и True, которые в свою очередь должны иметь свои правила вывода и т.д.

\hfill

После проверок спецификации (описанных в Секции~\ref{constraints}) строится структура хранящая информацию о правилах вывода, редукциях и конструкциях языка. С её помощью происходит кодогенерация представления термов языка и функций проверки типов и нормализации.

Было выбрано представление структур данных в виде индексов де Брейна\cite{de_brujin} через полиморфную рекурсию (подробнее в Секции~\ref{de_brujin_impl}). Само представление де Брейна имеет ряд преимуществ: $\alpha$-эквивалентность превращается в проверку на равенство и не возникает проблем захвата свободных переменных (подробнее в Секции~\ref{de_brujin}).

Использование полиморфной рекурсии для выражения индексов де Брейна имеет дополнительные преимущества:
\begin{itemize}
  \item Проверка корректности построения термов на уровне типов (нельзя писать Lam 123, тк лямбда захватывает только одну переменную).
  \item Можно абстрагировать это представление, превратив Scope в трансформер монад. Тогда нам остается лишь определить представителя класса Monad для нашего представления термов (работает как подстановка), что делается комически просто.
  \item Абстрагирование представления дает нам функции abstract и instantiate, которые абстрагируют переменную и инстанциируют самую внешнюю связную переменную соответственно.
  \item С помощью механизма Deriving Haskell можно получить представителя классов Functor, Traversable и Foldable. Что дает нам функции toList --- список свободных переменных терма и traverse --- применить аппликативную функцию к переменным терма.
  \item Можно определить обобщенные Show и Eq --- не теряем простоты более простого представления.
\end{itemize}


\begin{lstlisting}[caption={Сгенерированное представление АСТ STLC на Haskell и представитель класса Monad},captionpos=b, frame=single, float, floatplacement=H]
data Term a = Var a
            | TyDef
            | App (Type a) (Term a) (Term a)
            | Lam (Type a) (Scope Term a)
            | Arrow (Type a) (Type a)

instance Monad Term where
      Var v1 >>= f = f v1
      TyDef >>= f = TyDef
      App v1 v2 v3 >>= f = App (v1 >>= f) (v2 >>= f) (v3 >>= f)
      Lam v1 v2 >>= f = Lam (v1 >>= f) (v2 >>>= f)
      Arrow v1 v2 >>= f = Arrow (v1 >>= f) (v2 >>= f)
\end{lstlisting}

Затем происходит генерация функций infer и nf, так как остальные функции --- проверки типа терма, печати терма, функции управления контекстами --- не зависят от специфицируемого языка.

Функция nf сопоставляет терм с образцом, сгенерированном для каждой левой части редукции. Если происходит совпадение --- строит правую часть совпавшей редукции. Если нет совпадения то возвращает конструкцию, которую приняла, предварительно применив себя же ко всем внутренним термам.

Функция infer сопоставляет терм с образцом, наличие правил вывода для всех конструкций гарантирует совпадение хоть с одним образцом. Затем проверяет каждую предпосылку отдельно и возвращает тип терма, который ей был передан, в соответствии с правилом вывода конструкции (если терм переданный не является представителем сорта термов возвращается аналог кайнда * для данного сорта).

Для построения правой части мы должны уметь строить термы из имеющихся у нас метапеременных, это описано в деталях в Секции~\ref{build_exp}.

Затем используется библиотека Haskell.src.exts\cite{src_exts} для замены структур данных и функций заглушек в написанном от руки модуле LangTemplate.

Полученный код компилируется Haskell, и на нем можно описывать термы специфицированного языка, его контекст и выводить тип терма или приводить его в нормальную форму.


%%








%%
