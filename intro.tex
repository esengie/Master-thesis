\section*{Введение}
Формальные языки с зависимыми типами могут быть использованы для доказательств свойств кода программы. Также в языке с зависимыми возможно определить типы, аналогичные сущностям области математики, в которой мы хотим доказывать теоремы и просто писать термы, таким образом предъявляя доказательства утверждений. Это называется соответствием Карии-Говарда-Ламбека\cite{curry_how}. Достоинство данного подхода заключается в том, что проверка доказательств перекладывается на алгоритм проверки типов соответсвующего языка --- во многих случаях автоматизированный процесс.

Наиболее известными примерами языков, которые пользуются соответствием Карри-Говарда для доказательства математических утверждений являются Coq\cite{coq} и Agda\cite{agda}. Например, доказательство теоремы о четырех красках было завершено в 2005 году с помощью Coq\cite{weisstein2002four}.
Пример относительно простого доказательства корректности функции filter на Agda приведен в Приложении~\ref{sort_proof}.

\hfill

В процессе формализации теории может возникнуть ситуация, что конструкции, которыми мы хотим пользоваться, не существуют в языке программирования. Поэтому, если мы хотим переложить верификацию наших высказываний на алгоритм проверки типов соответствующего языка с зависимыми типами, приходится писать свой язык программирования и уже в нем доказывать утверждения.

Так как типы зависимого языка могут включать в себя произвольные термы, проверка типов является задачей тесно связанной с вычислением языка\footnote{В дальнейшем мы понимаем вычисление как переписывание термов согласно редукциям языка, пока не получим терм к которому ни одна редукция неприменима --- этот процесс называется приведением терма в \textit{нормальную форму}.}. Поэтому написание функции проверки типов языка становится достаточно ёмкой задачей. В работе описан способ генерации библиотеки Haskell\cite{haskell} для работы со специфицированным языком, в которой есть функции проверки типов, нормализации, работы с контекстами и стандартные операций над термами (такие как подстановка и абстракция).

\hfill

Зависимые языки состоят из конструкций языка и их семантика задается с помощью правил вывода и редукций. В работе использована ``типизация'' конструкций\footnote{Это сделано ещё и потому, что работа основана на~\cite{isaev}. В статье предложено описание языков в виде существенно алгебраических теорий. У специфицируемого языка есть конструкции, правила вывода и редукции что транслируется в сигнатуру и аксиомы, соответствующей алгебраической теории.}, аналогично языку проверки свойств спецификаций языка Twelf~\cite{twelf}.

В спецификации задаются метатипы метапеременных (сорта) и конструкций, сами конструкции, правила вывода каждой конструкции и правила редукции языка. Всегда существует сорт зависимых термов и сорт [зависимых] типов. Во вставке кода~\ref{lst_stlc} приведена спецификация STLC\cite{stlc}. Стандартная нотация (x y).T означает, что контекст данной переменной содержит ещё две переменных в дополнение к существующему общему контексту. Конструкции языка, которые имеют в качестве аргументов (sort, $n > 0$) связывают $n$ переменных.

\begin{lstlisting}[label={lst_stlc}, caption={Описание STLC при помощи языка специфкаций},captionpos=b, frame=single, float, floatplacement=H]
Dependent sorts:
  tm
SimpleSorts:
  ty
FunctionalSymbols:
  lam: (ty,0)*(tm,1) -> tm
  app: (ty,0)*(tm,0)*(tm,0) -> tm
  arrow: (ty,0)*(ty,0) -> ty
Axioms:
  TAbs =
    forall S : ty , T : ty , x.t : tm
      x : S |- t : T |--- |- lam(S , x.t) : arrow(S, T)
  TApp =
    forall t1 : tm , t2 : tm , S : ty, x.T : ty
      |- t1 : arrow(S, T), |- t2 : S
      |------------------------------
      |- app(T, t1 , t2) : T
  IArrow =
    forall T1 : ty , T2 : ty
      |--- |- arrow(T1, T2) def
Reductions:
  Beta =
    forall x.b : tm, A : ty, a : tm, T : ty
       |--- |- app(T, lam(A, x.b), a) => b[x := a]
\end{lstlisting}

Также спецификация позволяет задать с-стабильность правил вывода относительно замкнутых типов, что означает, что данная конструкция применима только в случае наличия свободных переменных только указанных типов. Например, если мы хотим, чтобы $\lambda$-абстракцию можно было применять только, если все свободные переменные внутри неё имеют тип Bool или являются функциями из Bool в Bool, мы аннотируем наше правило вывода соответсвующими типами так, как показано во вставке~\ref{lst_add_bool}.

\begin{lstlisting}[label={lst_add_bool}, caption={Пример спецификации того, что конструкция $\lambda$ должна быть стабильна относительно типа Bool и Bool $\rightarrow$ Bool},captionpos=b, frame=single, float, floatplacement=H]
FunctionalSymbols:
  lam: (ty,0)*(tm,1) -> tm
  app: (ty,0)*(tm,0)*(tm,0) -> tm
  arrow: (ty,0)*(ty,0) -> ty
  bool: ty
Axioms:
  IBool =
    |--- |- Bool def

  [bool, arrow(bool, bool)]
  TAbs =
    forall S : ty , T : ty , x.t : tm
      x : S |- t : T |--- |- lam(S, x.t) : arrow(S, T)
\end{lstlisting}

Чтобы это сделать в STLC появится новая конструкция и правило вывода соответствующая новому типу Bool. Вполне вероятно, мы захотим, чтобы тип имел стандартных представителей False и True, которые в свою очередь должны иметь свои правила вывода и связанные с ними конструкции (например If-then-else).

\hfill

После проверок спецификации (описанных в Секции~\ref{constraints}) строится структура хранящая информацию о правилах вывода, редукциях и конструкциях языка. С её помощью происходит кодогенерация представления термов языка и функций проверки типов и нормализации.

Было выбрано представление структур данных в виде индексов де Брейна\cite{de_brujin} через полиморфную рекурсию (подробнее в Секции~\ref{de_brujin_impl}). Само представление де Брейна имеет ряд преимуществ: $\alpha$-эквивалентность превращается в проверку на равенство, и не возникает проблем захвата свободных переменных (подробнее в Секции~\ref{de_brujin}). Пример представлен во вставке~\ref{lst_gen_stlc}. Как видно роль индексов играет оборачивание термов в конструктор Scope.

Использование полиморфной рекурсии для выражения индексов де Брейна имеет дополнительные преимущества:
\begin{itemize}
  \item Проверка корректности построения термов на уровне типов (невозможно написать терм Lam 123 в пустом контексте, так как $\lambda$ захватывает только одну переменную).
  \item Можно абстрагировать это представление, превратив Scope в трансформер монад. Тогда нам остается лишь определить представителя класса Monad для нашего представления термов (bind работает как подстановка), что делается крайне просто с точки зрения кодогенерации.
  \item Абстрактное представления дает нам обобщенные функции abstract и instantiate, которые абстрагируют переменную и инстанциируют самую внешнюю связную переменную соответственно. Таким образом решается проблема представления подстановок.
  \item С помощью механизма Deriving Haskell можно получить представителя классов Functor, Traversable и Foldable. Что дает нам функции toList --- список свободных переменных терма --- и traverse --- применить аппликативную функцию к переменным терма.
  \item Можно определить обобщенные Show и Eq --- не теряем простоты использования более простого представления без полиморфной рекурсии.
\end{itemize}

\begin{lstlisting}[caption={Сгенерированное представление АСТ STLC на Haskell и представитель класса Monad},captionpos=b, frame=single, float, floatplacement=H, label={lst_gen_stlc}]
data Term a = Var a
            | TyDef
            | App (Type a) (Term a) (Term a)
            | Lam (Type a) (Scope Term a)
            | Arrow (Type a) (Type a)

instance Monad Term where
      Var v1 >>= f = f v1
      TyDef >>= f = TyDef
      App v1 v2 v3 >>= f = App (v1 >>= f) (v2 >>= f) (v3 >>= f)
      Lam v1 v2 >>= f = Lam (v1 >>= f) (v2 >>>= f)
      Arrow v1 v2 >>= f = Arrow (v1 >>= f) (v2 >>= f)
\end{lstlisting}

Затем происходит генерация функций infer и nf, а остальные функции --- проверки типа терма, печати терма, функции управления контекстами --- не зависят от специфицируемого языка.

\hfill

Функция nf (подробнее про nf и infer в Секциях~\ref{typecheck}~и~\ref{nf_infer}) сопоставляет терм с образцом, сгенерированном для каждой левой части редукции. Если происходит совпадение --- строит правую часть совпавшей редукции. Если нет совпадения, то возвращает конструкцию, которую приняла, предварительно применив себя же ко всем внутренним термам.

Функция infer сопоставляет терм с образцом, наличие правил вывода для всех конструкций гарантирует совпадение хоть с одним образцом. Затем проверяет каждую предпосылку отдельно и возвращает тип терма, который ей был передан в соответствии с правилом вывода конструкции. Если переданный терм не является представителем сорта термов, возвращается аналог кайнда * для данного сорта.

Для построения термов из переданных нам аргументов функции мы должны уметь строить термы из имеющихся у нас метапеременных, это описано в деталях в Секции~\ref{build_exp}.

Затем используется библиотека Haskell.src.exts\cite{src_exts} для замены структур данных и функций заглушек в написанном от руки модуле LangTemplate.

Полученный код компилируется Haskell, и на нем можно описывать термы специфицированного языка, его контекст и выводить тип терма или приводить его в нормальную форму.


%%








%%
