\section{Зависимые языки} \label{deptypes_intro}
Языки с зависимыми типами позволяют типам зависеть от термов, то есть мы, например, можем иметь тип списков фиксированной длины. Что позволяет нам описывать ограничения налагаемые на использование функций, которые мы пишем.

Одной из наиболее частых ошибок при программировнии на языке вида Haskell является взятие первого элемента списка.
\begin{lstlisting}
head :: [a] -> a
head (x:_) = x
head [] = error "No head!"
\end{lstlisting}

Которая легко решается если мы можем иметь термы языка в типе.
\begin{lstlisting}
head :: {n : N} -> Vec a (suc n) -> a
head (x:_) = x
\end{lstlisting}
Здесь тип явно специфицирует что функция не принимает термы типа 'Vec a 0'

Этот способ обобщается и можно доказывать корректность работы алгоритмов, например функции сортировки в~(\ref{sort_proof})

\subsection{Проверка типов в зависимых языках}
Рассмотрим пример:

Если считать что заключение правила вывода, то проверка типов в любом языке происходит так: мы имеем некоторые аргументы внутри примитива, которые мы используем для составления узлов-потомков (предпосылок). И на этих узлах вызываем функцию вывода типов в возможно расширенном контексте\footnote{конечно мы должны для каждого расширения котнекста проверять его корректность} рекурсивно. Если потомки составлены корректно, то получаем некие типы которые можем использовать в проверке некоторых равенств и возрате типа примитива.

В зависимых языках все точно так же, однако проверка на равенство должна происходить после нормализации термов. Нормализацию мы применяем только после того как убедимся, что термы корректно составлены. То есть имеем факт того, что нормализация тесно связана с проверкой типов, а именно: проверка типов невозможна без нормализации термов. Действительно, чтобы понять что $2 + 3 = 5$ мы должны провести вычисления и убедиться в этом.







%--
