\section{Зависимые языки} \label{deptypes_intro}
Во многих языках программирования возникают ошибки связанные с доступом за границу массива.
Аналогом этого в Haskell является взятие первого элемента в списке.

\begin{lstlisting}[frame=single]
head :: [a] -> a
head (x:_) = x
head [] = error "No head!"
\end{lstlisting}

Такие ситуациях обычно решаются с помощью механизма исключений или его аналогов. Однако эту проблему можно решить иначе, наложив на вход дополнительные ограничения. А именно --- не принимать некорректные входные данные.

\begin{lstlisting}[frame=single]
head :: {n : N} -> Vec a (suc n) -> a
head (x:_) = x
\end{lstlisting}

Здесь тип явно специфицирует, что функция не принимает термы типа `Vec a 0'. Языки с зависимыми типами позволяют типам зависеть от термов, именно это позволяет описать тип списков фиксированной длины.

Как правило, программисты все равно проверяют какие-то ограничения перед вызовом функции или обладают дополнительной информацией, на основе которой они пишут код так, как они его пишут. В зависимых языках мы можем писать программы, где передача этого знания будет явно требоваться компилятором, что позволяет не допускать такого рода ошибки.

Этот способ обобщается, и можно доказывать корректность работы алгоритмов, например функции filter в Приложении~\ref{sort_proof}.

\subsection{Проверка типов в зависимых языках}\label{typecheck}
Рассмотрим пример правила вывода:

\begin{center}
\AxiomC{$\Gamma, x : S \vdash T\ type $}
\AxiomC{$\Gamma, \vdash f : \Pi(S, T) $}
\AxiomC{$\Gamma \vdash t : S $}
\TrinaryInfC{$\Gamma \vdash app(T, f, t) : T[x:=t]$}
\DisplayProof
\end{center}

Это пример правила вывода применения зависимой функции. $\Pi$ принимает в качестве аргумента терм и в зависимости от аргумента возвращает тип, обычные функции через $\Pi$ выражаются просто --- они всегда возвращают один и тот же тип.

Правила вывода можно представлять как узлы дерева вывода, где заключение является предком всех предпослок. Проверка типов в любом языке это обход АСТ и происходит так: мы имеем некоторые аргументы внутри примитива, которые мы используем для составления узлов-потомков (предпосылок). На этих узлах вызываем функцию вывода типов в возможно расширенном контексте\footnote{Конечно, мы должны для каждого расширения контекста проверять его корректность.} рекурсивно. Если потомки составлены корректно, то получаем некие типы, которые можем использовать в проверке равенств в предпосылках и возрате типа примитива.

В зависимых языках все точно так же, однако проверка на равенство должна происходить после нормализации термов. Нормализацию мы применяем только после того как убедимся, что термы корректно составлены. Получается, что нормализация тесно связана с проверкой типов. Более того проверка типов невозможна без нормализации термов.

Давайте разберём алгоритм на примере выше.
\begin{enumerate}
\item Чтобы проверить терм $app(T, f, t)$ (и вернуть его тип $T[x:=t]$), поочередно проверяем предпосылки. \item Вызываемся рекурсивно на терме $t$ и, если не произошло ошибки, получаем тип $S$.
\item Расширяем контекст типом $S$ и проверяем ``тип'' $T$ (на самом деле мы проверяем тип $T$ на определенность).
\item Вызываемся рекурсивно на $f$ --- получаем его тип. Теперь нужно проверить его на равенство типу $\Pi(S, T)$, который мы строим из имеющихся метапеременных. Подразумевается равенство нормальных форм. Соответственно равенство должно быть вызвано на нормализованных типах.
\item Если мы дошли до этой стадии, значит все определено корректно и мы возвращаем тип $T[x:=t]$
\end{enumerate}

Можно заметить, что мы должны уметь корректно выполнять подстановки и проверять термы на равенство, равенство подразумевается до $\alpha$-эквивалентности.

\subsection{Индексы де Брейна}\label{de_brujin}
При реализации функциональных языков одной из сложных проблем встающих перед программистом является выбор представления. Также нужно описывать подстановки\footnote{В работе подразумевается реализация языков программирования через описание AST на Haskell.} и многие проблемы и ошибки в реализации связаны с подстановками.

Одной из проблем представления термов является сравнение $\alpha$-эквивалентных термов. \textit{$\alpha$-эквивалентными} называются термы, которые отличаются только в именовании связанных переменных. Например, следующие три терма $\alpha$-эквивалентны:

\begin{lstlisting}
lamb x y → y (x z)
lamb y x → x (y z)
lamb a b → b (a z)
\end{lstlisting}

Одним из возможных способов представления термов является представление переменных в виде строк. С использованием такого подхода первый приведенный выше терм записывается в виде \lstinline{[Lam ``x'' (Lam ``y'' (App ``y'' (App ``x'' ``z'')))]}. Проверка равенства этого терма второму терму \lstinline{[Lam ``y'' (Lam ``x'' (App ``x'' (App ``y'' ``z'')))]} не тривиальна.

Другой проблемой такого представления термов является захвата свободных переменных при подстановке. Предположим, мы подставляем первый терм ниже в переменную ``z'' во втором.
\begin{lstlisting}
lamb x → y
lamb y → z
lamb y → lamb x → y = lamb y x → y
\end{lstlisting}

Очевидно, что подставлять в переменную так наивно нельзя, так как ``y'' стала связанной, хотя не была таковой в первоначальном терме.

Ключевым замечанием является то, что переменные в функциональных языках являются ``указателями'' на место их связывания --- этаким индексом в контекст --- и не несут никакой дополнительной информации.

Результат использования этого наблюдения называется индексами де Брейна. А именно: для каждой связанной переменной мы просто пишем расстояние от неё до ближайшего связывания.

Если переписать термы с альфа эквивалентностью выше, то для всех трех термов получим \lstinline{[lamb lamb → 1 (2 z)]}, и проверка на альфа-эквивалентность превращается в проверку на равенство.

Также решается проблема избегания захвата переменных, а именно:
\begin{lstlisting}
lamb → y
lamb → z
lamb → lamb → y = lamb lamb → y
\end{lstlisting}

Как видно ``y'' остался свободным.

Это представление значительно лучше удовлетворяет нашим требованиям разработчика языков. Мы перешли от
\lstinline{[Lam ``y'' (Lam ``x'' (App ``x'' (App ``y'' ``z'')))]} к \lstinline{[Lam (Lam (App 1 (App 2 ``z'')))]}.

Однако общей проблемой обоих представлений является нетипизированность переменных --- никто не контролирует построение термов вида \lstinline{[Lam (Lam (App 123 (App 23 ``z'')))]}. Решение этой проблемы описано в секции~\ref{de_brujin_impl}.









%--
