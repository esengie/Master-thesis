\section{Языки с зависимыми типами} \label{deptypes_intro}
Во многих языках программирования возникают ошибки связанные с доступом за границу массива.
Аналогом этого в Haskell является взятие первого элемента в списке.

\begin{lstlisting}[frame=single]
head :: [a] -> a
head (x:_) = x
head [] = error "No head!"
\end{lstlisting}

Такие ситуациях обычно решаются с помощью механизма исключений или его аналогов. Однако эту проблему можно решить иначе, наложив на вход дополнительные ограничения. А именно --- не принимать некорректные входные данные.

\begin{lstlisting}[frame=single]
head :: {n : N} -> Vec a (suc n) -> a
head (x:_) = x
\end{lstlisting}

Здесь тип явно специфицирует, что функция не принимает термы типа `Vec a 0'. Языки с зависимыми типами позволяют типам зависеть от выражений языка, именно это позволяет описать тип списков фиксированной длины.

Как правило, программисты все равно проверяют какие-то ограничения перед вызовом функции или обладают дополнительной информацией, на основе которой они пишут код так, как они его пишут. В зависимых языках мы можем писать программы, где передача этого знания будет явно требоваться компилятором, что позволяет не допускать такого рода ошибки.

Этот способ обобщается, и можно доказывать корректность работы алгоритмов, например функции filter в Приложении~\ref{sort_proof}.

\subsection{Проверка типов в зависимых языках}\label{typecheck}
Выражения нашего языка мы будет называть \textit{термами} --- они строятся индуктивно из применений конструкций языка к другим конструкциям или переменным. Обычно в тексте под термом подразумевается выражения определенного уровня языка, а именно все, что не является типом (или видом). Однако `терм' может означать `любого выражения языка', обычно в тексте такое значение можно отличить от предыдущего тем, что в этом значении оно используется в выражении \textit{терм языка}.

Языки с зависимыми типами обычно задаются через формализм написаний правил вывода (для описания языка целиком см. Раздел~\ref{lang_spec}). Рассмотрим пример правила вывода:

\begin{center}
\AxiomC{$\Gamma, x : S \vdash T\ type $}
\AxiomC{$\Gamma, \vdash f : \Pi(S, T) $}
\AxiomC{$\Gamma \vdash t : S $}
\TrinaryInfC{$\Gamma \vdash app(T, f, t) : T[x:=t]$}
\DisplayProof
\end{center}

Введём несколько определений, которые будем использовать дальше во всем тексте. Все переменные, являясь переменными мета-языка описания языков называются \textit{метапеременными}. Каждая конструкция вида ``$... \vdash ...$'' называется \textit{суждением}. Все что левее символа $\vdash$ называется \textit{контекстом}. Все суждения, что находятся выше черты, называется \textit{предпосылками}. Суждение под чертой называется \textit{заключением} правила вывода.

Само правило является правилом вывода применения зависимой функции. Конструкция языка $\Pi$ принимает в качестве аргумента терм и в зависимости от аргумента возвращает тип, привычные нам независимые функции через $\Pi$ выражаются как константные функции, так как всегда возвращают один и тот же тип.

Правила вывода можно представлять как узлы дерева вывода, где заключение является предком всех предпослок. Проверка типов в любом языке это обход АСД и происходит так: мы имеем некоторые аргументы внутри примитива, которые мы используем для составления узлов-потомков (предпосылок). На этих узлах вызываем функцию вывода типов в возможно расширенном контексте (конечно, мы должны для каждого расширения контекста проверять его корректность) рекурсивно. Если потомки составлены корректно, то получаем некие типы, которые можем использовать в проверке равенств в предпосылках и возрате типа примитива.

В зависимых языках все точно так же, однако проверка на равенство должна происходить после нормализации термов. Нормализацию мы применяем только после того, как убедимся, что термы корректно составлены. Получается, что нормализация тесно связана с проверкой типов.

Давайте разберём алгоритм на примере выше.
\begin{enumerate}
\item Чтобы проверить терм $app(T, f, t)$ (и вернуть его тип $T[x:=t]$), поочередно проверяем предпосылки.
\item Вызываемся рекурсивно на терме $t$ и, если не произошло ошибки, получаем тип $S$.
\item Расширяем контекст типом $S$ и проверяем ``тип'' $T$ (на самом деле мы проверяем тип $T$ на определенность).
\item Вызываемся рекурсивно на $f$ --- получаем его тип. Теперь нужно проверить равенство его нормальной формы нормальной форме типа $\Pi(S, T)$, который мы строим из имеющихся метапеременных.
\item Если мы дошли до этой стадии, значит все определено корректно и мы возвращаем тип $T[x:=t]$
\end{enumerate}

Можно заметить, что мы должны уметь корректно выполнять подстановки и проверять термы на равенство, равенство подразумевается до $\alpha$-эквивалентности. \textit{$\alpha$-эквивалентными} называются термы, которые отличаются только в именовании связанных переменных. Поэтому при реализации языка мы должны заботиться о выборе корректного представления, чтобы подстановка и равенство не требовали больших усилий при их написании.





%--
