\section{Языки с зависимыми типами} \label{deptypes_intro}
Во многих языках программирования возникают ошибки связанные с доступом за границу массива.
Аналогом этого в Haskell является взятие первого элемента в списке.

\begin{lstlisting}[frame=single]
head :: [a] -> a
head (x:_) = x
head [] = error "No head!"
\end{lstlisting}

Такие проблемы обычно решаются с помощью использования механизма исключений или его аналогов. Однако эту проблему можно решить иначе, просто наложив на вход дополнительные ограничения. А именно --- не принимать некорректные входные данные.

\begin{lstlisting}[frame=single]
head :: {n : N} -> Vec a (suc n) -> a
head (x:_) = x
\end{lstlisting}

Здесь тип явно специфицирует, что функция не принимает термы типа `Vec a 0'. Языки с зависимыми типами позволяют типам зависеть от произвольных выражений языка, именно это и позволяет описать тип списков фиксированной длины.

Как правило, программисты все равно проверяют какие-то ограничения перед вызовом функции или обладают дополнительной информацией, на основе которой они пишут код так, как они его пишут. В зависимых языках мы можем писать программы, где передача этого знания будет явно требоваться компилятором, что позволяет не допускать такого рода ошибки.

Этот способ обобщается, и можно доказывать корректность работы алгоритмов, например функции filter в Приложении~\ref{sort_proof}.

\subsection{Проверка типов в зависимых языках}\label{typecheck}
Выражения нашего языка строятся индуктивно из применений конструкций языка к другим конструкциям или переменным. Обычно в тексте под \textit{термами} подразумеваются выражения определенного уровня языка, а именно все выражения, которые не являются типами (или видами).

Языки с зависимыми типами обычно задаются через формализм написаний правил вывода (для примера формального описания языка целиком см. Раздел~\ref{lang_spec}). Рассмотрим пример правила вывода:

\begin{center}
\AxiomC{$\Gamma, x : S \vdash T\ type $}
\AxiomC{$\Gamma, \vdash f : \Pi(S, T) $}
\AxiomC{$\Gamma \vdash t : S $}
\TrinaryInfC{$\Gamma \vdash app(T, f, t) : T[x:=t]$}
\DisplayProof
\end{center}

Введём несколько определений, которые будем использовать дальше во всем тексте. Все переменные, являясь переменными мета-языка описания языков называются \textit{метапеременными} --- таким образом мы отличаем их от переменных языка, который мы специфируем. Каждая конструкция вида `$... \vdash ...$' называется \textit{суждением}. Все, что находится левее символа `$\vdash$', называется \textit{контекстом}. Все суждения, что находятся выше черты, называется \textit{предпосылками}. Суждение под чертой называется \textit{заключением} правила вывода.

Само правило, представленное выше, является правилом вывода применения зависимой функции. Конструкция языка $\Pi$ принимает в качестве аргумента терм и в зависимости от аргумента возвращает тип, привычные нам независимые функции через $\Pi$ выражаются как константные функции, так как всегда возвращают один и тот же тип.

Правила вывода можно представлять как узлы дерева вывода, где заключение является предком всех предпослок. Проверка типов в любом языке это обход АСД и происходит так: мы имеем некоторые аргументы внутри конструкции, которые мы используем для составления узлов-потомков (предпосылок). На этих узлах вызываем функцию вывода типов в возможно расширенном контексте (каждое расширение контекста должно проверяться на корректность, так как типы в контексте могут зависеть от типов в контексте до них) рекурсивно. Если потомки составлены корректно, то получаем типы потомков, которые можем использовать в проверке равенств в предпосылках и возрате типа примитива.

В зависимых языках все точно так же, однако проверка на равенство должна происходить после нормализации выражений. Нормализацию мы применяем только после того, как убедимся, что выражения корректно составлены. Получается, что нормализация тесно связана с проверкой типов.

Разберём работу алгоритма проверки типов на примере правила вывода выше:
\begin{enumerate}
\item Чтобы проверить терм $app(T, f, t)$ (и вернуть его тип $T[x:=t]$), поочередно проверяем предпосылки.
\item Вызываемся рекурсивно на терме $t$ и, если не произошло ошибки, получаем его тип $S$.
\item Расширяем контекст типом $S$ и рекурсивно вызываемся на типе $T$, таким образом проверяя корректность его определения.
\item Вызываемся рекурсивно на $f$ --- получаем его тип. Теперь нужно проверить равенство нормальной формы его типа нормальной форме типа $\Pi(S, T)$, который мы строим из имеющихся типов $S$ и $T$.
\item Если мы дошли до этой стадии, значит все определено корректно и мы возвращаем тип $app(T, f, t)$ --- $T[x:=t]$
\end{enumerate}

Можно заметить, что мы должны уметь корректно выполнять подстановки и проверять выражения на равенство, равенство подразумевается до $\alpha$-эквивалентности. \textit{$\alpha$-эквивалентными} называются выражения, которые отличаются только в именовании связанных переменных. Поэтому при реализации языка мы должны заботиться о выборе корректного представления, чтобы подстановка и равенство не требовали больших усилий при их написании.





%--
