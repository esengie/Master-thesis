\section{Зависимые языки} \label{deptypes_intro}
Во многих языках программирования возникают ошибки связанные с доступом за границу массива.
Аналогом этого в Haskell является взятие первого элемента в списке.

\begin{lstlisting}[frame=single]
head :: [a] -> a
head (x:_) = x
head [] = error "No head!"
\end{lstlisting}

Такие ситуациях обычно решаются с помощью механизма исключений или его аналогов. Однако эту проблему можно решить иначе, наложив на вход дополнительные ограничения. А именно --- не принимать некорректные входные данные.

\begin{lstlisting}[frame=single]
head :: {n : N} -> Vec a (suc n) -> a
head (x:_) = x
\end{lstlisting}

Здесь тип явно специфицирует, что функция не принимает термы типа `Vec a 0'. Языки с зависимыми типами позволяют типам зависеть от термов, именно это позволяет описать тип списков фиксированной длины.

Как правило, программисты все равно проверяют какие-то ограничения перед вызовом функции или обладают дополнительной информацией, на основе которой они пишут код так, как они его пишут. В зависимых языках мы можем писать программы, где передача этого знания будет явно требоваться компилятором, что позволяет не допускать такого рода ошибки.

Этот способ обобщается, и можно доказывать корректность работы алгоритмов, например функции filter в Приложении~\ref{sort_proof}.

\subsection{Проверка типов в зависимых языках}\label{typecheck}
Рассмотрим пример правила вывода:

\begin{center}
\AxiomC{$\Gamma, x : S \vdash T\ type $}
\AxiomC{$\Gamma, \vdash f : \Pi(S, T) $}
\AxiomC{$\Gamma \vdash t : S $}
\TrinaryInfC{$\Gamma \vdash app(T, f, t) : T[x:=t]$}
\DisplayProof
\end{center}

Это правило вывода применения зависимой функции. Конструкция $\Pi$ принимает в качестве аргумента терм и в зависимости от аргумента возвращает тип, привычные нам независимые функции через $\Pi$ выражаются как константные функции, так как всегда возвращают один и тот же тип.

Правила вывода можно представлять как узлы дерева вывода, где заключение является предком всех предпослок. Проверка типов в любом языке это обход АСТ и происходит так: мы имеем некоторые аргументы внутри примитива, которые мы используем для составления узлов-потомков (предпосылок). На этих узлах вызываем функцию вывода типов в возможно расширенном контексте (конечно, мы должны для каждого расширения контекста проверять его корректность) рекурсивно. Если потомки составлены корректно, то получаем некие типы, которые можем использовать в проверке равенств в предпосылках и возрате типа примитива.

В зависимых языках все точно так же, однако проверка на равенство должна происходить после нормализации термов. Нормализацию мы применяем только после того, как убедимся, что термы корректно составлены. Получается, что нормализация тесно связана с проверкой типов.

Давайте разберём алгоритм на примере выше.
\begin{enumerate}
\item Чтобы проверить терм $app(T, f, t)$ (и вернуть его тип $T[x:=t]$), поочередно проверяем предпосылки.
\item Вызываемся рекурсивно на терме $t$ и, если не произошло ошибки, получаем тип $S$.
\item Расширяем контекст типом $S$ и проверяем ``тип'' $T$ (на самом деле мы проверяем тип $T$ на определенность).
\item Вызываемся рекурсивно на $f$ --- получаем его тип. Теперь нужно проверить равенство его нормальной формы нормальной форме типа $\Pi(S, T)$, который мы строим из имеющихся метапеременных.
\item Если мы дошли до этой стадии, значит все определено корректно и мы возвращаем тип $T[x:=t]$
\end{enumerate}

Можно заметить, что мы должны уметь корректно выполнять подстановки и проверять термы на равенство, равенство подразумевается до $\alpha$-эквивалентности. \textit{$\alpha$-эквивалентными} называются термы, которые отличаются только в именовании связанных переменных. Поэтому при реализации языка мы должны заботиться о выборе корректного представления, чтобы подстановка и равенство не требовали больших усилий при их написании.





%--
