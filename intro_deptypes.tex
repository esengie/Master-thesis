\section{Зависимые языки} \label{deptypes_intro}
Языки с зависимыми типами позволяют типам зависеть от термов, то есть мы, например, можем иметь тип списков фиксированной длины. Это позволяет нам описывать ограничения налагаемые на использование функций, которые мы пишем.

Одной из наиболее частых ошибок при программировнии на языке вида Haskell является взятие первого элемента пустого списка.

\begin{lstlisting}[frame=single]
head :: [a] -> a
head (x:_) = x
head [] = error "No head!"
\end{lstlisting}

Которая легко решается, если мы можем иметь термы языка в типе.

\begin{lstlisting}[frame=single]
head :: {n : N} -> Vec a (suc n) -> a
head (x:_) = x
\end{lstlisting}

Здесь тип явно специфицирует, что функция не принимает термы типа 'Vec a 0'

Этот способ обобщается, и можно доказывать корректность работы алгоритмов, например функции filter в Приложении~\ref{sort_proof}.

\subsection{Проверка типов в зависимых языках}\label{typecheck}
Рассмотрим пример:

\begin{center}
\AxiomC{$\Gamma, x : S \vdash T\ type $}
\AxiomC{$\Gamma, \vdash f : pi(S, T) $}
\AxiomC{$\Gamma \vdash t : S $}
\TrinaryInfC{$\Gamma \vdash app(T, f, t) : T[x:=t]$}
\DisplayProof
\end{center}

Если считать, что заключение правила вывода, то проверка типов в любом языке происходит так: мы имеем некоторые аргументы внутри примитива, которые мы используем для составления узлов-потомков (предпосылок).

На этих узлах вызываем функцию вывода типов в возможно расширенном контексте\footnote{Конечно, мы должны для каждого расширения контекста проверять его корректность.} рекурсивно. Если потомки составлены корректно, то получаем некие типы, которые можем использовать в проверке равенств в предпосылках и возрате типа примитива.

В зависимых языках все точно так же, однако проверка на равенство должна происходить после нормализации термов. Нормализацию мы применяем только после того как убедимся, что термы корректно составлены. То есть имеем, что нормализация тесно связана с проверкой типов. Более того проверка типов невозможна без нормализации термов.

Действительно, чтобы понять что $2 + 3 = 5$, мы должны провести вычисления и убедиться в этом.

\subsection{Индексы де Брейна}\label{de_brujin}
При реализации функциональных языков одной из самых сложных частей является написание подстановок. Большинство проблем и ошибок в реализации тоже связано с ней.

Одной из таких проблем является сравнение альфа-эквивалентных термов. Альфа-эквивалентными называются термы, которые отличаются только в именовании связанных переменных. Например, следующие три терма альфа-эквивалентны:

\begin{lstlisting}
lamb x y → y (x z)
lamb y x → x (y z)
lamb a b → b (a z)
\end{lstlisting}

Понятно, что мы сталкиваемся с проблемами при использовании переменных в виде строк, например первый терм сверху выглядел бы как \lstinline{[Lam "x" (Lam "y" (App "y" (App "x" "z")))]}. И проверка равенства этого терма терму \lstinline{[Lam "y" (Lam "x" (App "x" (App "y" "z")))]} занятие, склонное к ошибкам.

Другой проблемой такого представления термов является избегание захвата переменных при подстановке. Положим, мы подставляем первый терм ниже в переменную "z" во втором.
\begin{lstlisting}
lamb x → y
lamb y → z
lamb y → lamb x → y = lamb y x → y
\end{lstlisting}

Очевидно, что подставлять в переменную так наивно нельзя, так как "y" стала связанной, хотя не была таковой в первоначальном терме.

Ключевым замечанием является то, что переменные в функциональных языках являются "указателями" на место их связывания --- этаким индексом в контекст --- и не несут никакой дополнительной информации.

Результат использования этого наблюдения называется индексами де Брейна. А именно: для каждой связанной переменной мы просто пишем расстояние от неё до ближайшего связывания.

Если переписать термы с альфа эквивалентностью выше, то для всех трех термов получим \lstinline{[lamb lamb → 1 (2 z)]}, и проверка на альфа-эквивалентность превращается в проверку на равенство.

Также решается проблема избегания захвата переменных, а именно:
\begin{lstlisting}
lamb → y
lamb → z
lamb → lamb → y = lamb lamb → y
\end{lstlisting}

Как видно "y" остался свободным.

Это представление значительно лучше удовлетворяет нашим требованиям разработчика языков. Мы перешли от
\lstinline{[Lam "y" (Lam "x" (App "x" (App "y" "z")))]} к \lstinline{[Lam (Lam (App 1 (App 2 "z")))]}.

Однако общей проблемой обоих представлений является нетипизированность переменных --- никто не контролирует построение термов вида \lstinline{[Lam (Lam (App 123 (App 23 "z")))]}. Решение этой проблемы описано в секции~\ref{de_brujin_impl}.









%--
