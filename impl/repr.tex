\subsection{Структура модуля генерации кода}\label{repr}
Генерация кода происходит внутри монады GenM, которая является стэком монад: \lstinline{ReaderT SymbolTable (StateT CodeGen (ErrorM))}.

\begin{lstlisting}[caption={Структура используемая при кодогенерации},captionpos=b,frame=single]
data CodeGen = Gen{
, decls :: [Decl]
}
\end{lstlisting}

Так как структура заполняемая модулем проверки спецификации не меняется на этапе кодогенерации, она находится внутри монады ReaderT. При кодогенерации происходит генерация деклараций языка Haskell, которые хранятся в виде списка, затем все эти декларации будут добавлены в модуль опредения языка.

Во всей программе происходит генерация определений 4ех сущностей:
\begin{itemize}
\item Представления специфицированного языка
\item Представителя класса Monad для представления языка
\item Функции infer --- вывода типов терма
\item Функции nf --- приведения в нормальную форму/вычисления терма
\end{itemize}

Из описанных выше сущностей, только генерация последних двух представляет интерес. Так как остальные две, хоть и являются концептуально сложными для понимания, очень просты в генерации.

Из-за того, что функции infer и nf определяются при помощи сопоставления с образцом конструкций языка (или переменных), и каждое сопоставление с образцом считается отдельной декларацией АСД Haskell, можно считать генерацию каждой декларации в некотором смысле отдельной задачей. А именно --- все переменные введенные внутри одной декларации могут быть переиспользованы внутри другой.

Поэтому для генерации каждой отдельной декларации функций infer и nf создается внутренная монада BldRM, которая определена как \lstinline{StateT Q (ErrorM)}.

\begin{lstlisting}[caption={Структура используемая при кодогенерации функций infer и nf},captionpos=b,frame=single]
data Q = Q {
  _count :: Int,
  _doStmts :: [Stmt],
  _juds  :: Juds,

  _metas :: Map.Map MetaVar [(Ctx, Exp)],
  _foralls :: Map.Map MetaVar Sort,
  _funsyms :: Map.Map AST.Name FunctionalSymbol
}

data Juds = Juds {
  _metaTyDefs :: [(MetaVar, Judgement)],
  _notDefsTy :: [(Term, Judgement)],
  _otherJuds :: [Judgement]
}
\end{lstlisting}

Сама структура Q содержит всю информацию, нужную для генерации определения отдельной декларации функции infer и nf. Так как весь код, который генерируется будет исполнятся внутри монады, можно просто сгенерировать список выражений Haskell, а затем приписать сверху do, и таким образом будет обеспечен порядок выполнения выражений.

Для создания свободных переменных Haskell используется простой счетчик, так как вероятность появления большого количества переменных внутри одной декларации мала.

Все предпосылки делятся на три типа:
\begin{enumerate}
  \item Вводящие метапеременные --- меняют таблицу метапеременных. Удобно иметь соответствующую метапеременную, вводимая данным выражением.
  \item Имеющие тип у терма заключения, а значит нужно ещё строит этот тип и проверять его на равенство выведенному. Терм, на равенство которому будет проведена проверка, хранится рядом для удобства.
  \item Остальные --- просто нужно проверить на определенность.
\end{enumerate}

Это хранится в структуре Q в виде трёх списков предпосылок.

Также существует таблица, где для каждой метапеременной написан её контекст и терм языка Haskell, который ей соответствует в коде. Это нужно для генерации всех других термов специфицированного языка.

Хранится таблица всех метапеременных из подраздела forall и конструкций языка, так как в предпослыках вида \lstinline{...|- T def} и \lstinline{...|- f(...) def} нам нужно знать сорт метапеременной или сорт возвращаемый нашей конструкции, чтобы вернуть его из функции infer.

Для простоты реализации использована библиотека lens\cite{lens}. Что позволяет писать следующие функции в Haskell, например при манипуляции State:

\begin{lstlisting}[frame=single]
appendStmt :: Stmt -> BldRM ()
-- Modify part of the State using a function
appendStmt st = doStmts %= (++ [st])

genCheckMetaEq :: BldRM ()
genCheckMetaEq = do
  ms <- gets _metas
  -- Replaces metas inside State Monad
  metas <~ sequence (genMetaEq <$> ms)
\end{lstlisting}

А именно: \lstinline{doStmts %= (++ [st])} --- позволяет менять состояние, как будто бы мы применили мутирующую функцию к глобальной переменной. А код \lstinline{metas <~ sequence (genMetaEq <$> ms)} выглядит так, будто мы просто присваиваем результат монадического вычисления в ``глобальную'' переменную metas.











%%%
