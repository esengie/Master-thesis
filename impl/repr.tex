\subsection{Структура модуля генерации кода}\label{repr}
Генерация кода происходит внутри монады GenM, которая является стэком монад: \lstinline{ReaderT SymbolTable (StateT CodeGen (ErrorM))}.

\begin{lstlisting}[caption={Структура используемая при кодогенерации},captionpos=b,frame=single]
data CodeGen = Gen{
, decls :: [Decl]
}
\end{lstlisting}

Так как структура заполняемая модулем проверки спецификации не меняется на этапе кодогенерации, она находится внутри монады ReaderT. При кодогенерации происходит генерация деклараций языка Haskell, которые хранятся в виде списка.

При генерации каждой отдельной декларации функций infer и nf создается внутренная монада BldRM, которая определена как \lstinline{StateT Q (ErrorM)}.

\begin{lstlisting}[caption={Структура используемая при кодогенерации функции infer},captionpos=b,frame=single]
data Q = Q {
  _count :: Int,
  _doStmts :: [Stmt],
  _juds  :: Juds,

  _metas :: Map.Map MetaVar [(Ctx, Exp)],
  _foralls :: Map.Map MetaVar Sort,
  _funsyms :: Map.Map AST.Name FunctionalSymbol
}

data Juds = Juds {
  _metaTyDefs :: [(MetaVar, Judgement)],
  _notDefsTy :: [(Term, Judgement)],
  _otherJuds :: [Judgement]
}
\end{lstlisting}

Для простоты реализации так же как и в модуле проверки корректности спецификации (Секция~\ref{sortcheck}) использована библиотека lens\cite{lens}. Что позволяет писать следующие функции в Haskell, например при манипуляции State (акцент на использовании кода, выглядящего императивно):

\begin{lstlisting}[frame=single]
appendStmt :: Stmt -> BldRM ()
-- Modify part of the State using a function
appendStmt st = doStmts %= (++ [st])

genCheckMetaEq :: BldRM ()
genCheckMetaEq = do
  ms <- gets _metas
  -- Replaces metas inside State Monad
  metas <~ sequence (genMetaEq <$> ms)
\end{lstlisting}

Структура Q содержит всю информацию, нужную для генерации определения функций infer и nf. Так как весь код, который генерируется будет исполнятся внутри монады c возможностью обработки ошибок, можно просто сгенерировать список выражений Haskell, а затем приписать сверху do, таким образом будет обеспечен порядок выполнения выражений.

Для создания свободных переменных используется простой счетчик, так как вероятность появления большого количества переменных внутри одной декларации мала.

Все предпосылки делятся на три типа:
\begin{enumerate}
  \item Вводящие метапеременные --- меняют таблицу метапеременных. Удобно иметь соответствующую метапеременную, вводимая данным выражением.
  \item Имеющие тип у терма заключения, а значит нужно ещё строит этот тип и проверять его на равенство выведенному. Терм, на равенство которому будет проведена проверка, хранится рядом для удобства.
  \item Остальные --- просто нужно проверить на определенность.
\end{enumerate}

Это хранится в структуре Q в виде трёх списков предпосылок.

Также существует таблица, где для каждой метапеременной написан её контекст и терм языка Haskell, который ей соответствует в коде. Это нужно для генерации всех других термов специфицированного языка.

Хранится таблица всех метапеременных из секции forall и функциональных символов, так как в предпослыках вида \lstinline{...|- T def} и \lstinline{...|- f(...) def} нам нужно знать сорт метапеременной или сорт возвращаемый нашим функциональным символом, чтобы вернуть его из функции infer.



























%%%
