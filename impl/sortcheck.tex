\subsection{Модуль проверки корректности спецификации}\label{sortcheck}
Вся проверка корректности проходит внутри монады SortCheckM, которая является стэком монад StateT и Either. Понятно, что Either используется для обработки ошибок.

А State нужен, так как в ходе работы алгоритма постепенно заполняется таблица определений языка спецификации.


\begin{lstlisting}[caption={Структура заполняемая модулем проверки спецификации},captionpos=b,frame=single, label={SymTab}]
data SymbolTable = SymbolTable {
  stabs         :: AST.Stab
, depSorts      :: Set AST.SortName
, simpleSorts   :: Set AST.SortName
, funSyms       :: Map AST.Name AST.FunctionalSymbol
, axioms        :: Map AST.Name Axiom
, reductions    :: Map AST.Name Reduction
, iSymAxiomMap  :: Map AST.Name AST.Name -- intro axioms of funSyms
}
\end{lstlisting}


Изначально заполняются множества зависимых и независимых сортов. Затем происходит проверка и заполнение определения функций.

Сами аксиомы и редукции, ввиду однопроходности синтаксического анализатора могут быть заполнены изначально некорректно. Все 0-арные функциональные символы и все метапеременные синтаксическим анализатором распознаются как переменные. Это поправляется на этапе рекурсивного обхода переменных. Сперва просматривается таблица функциональных символов затем метапеременных аксиомы/редукции. Если ни там, ни в другом месте ничего не находится считается, что это переменная и проверяется на перекрытие других переменных.

Затем проводятся проверки описанные в Секции~\ref{constraints}. Эти проверки достаточно очевидно ложатся на код, поэтому описывать здесь их не имеет особого смысла.




















%%%
