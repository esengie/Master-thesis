\pagebreak
\subsection{Индексы де Брейна на уровне типов}\label{de_brujin_impl}
В нашем описании индексов де Брейна в Cекции~\ref{de_brujin} мы упомянули, что наивное их использование склонно к ошибкам и не использует систему типов Haskell.

Эту проблему можно решить с помощью полиморфной рекурсии\cite{Bird:Pat}. По сути, каждый раз когда мы абстрагируемся по переменной в представлении де Брейна, мы добавляем единицу ко всем связанным переменным внутри терма. Ключевым наблюдением является то, что мы можем добавлять единицу оборачивая терм в Maybe. Например:


\begin{lstlisting}[frame=single]
data Term a
  = Var a
  | App (Term a) (Term a)
  | Lam (Term (Maybe a))
\end{lstlisting}


Однако этот метод не очень удобен при кодогенерации, так как instance Monad будет зависет от определения Term. В той же статье предложен способ превращения этого паттерна программирования в трансформер монад\footnote{В коде Maybe заменен на Var, в соответствии со своей семантикой.}.


\begin{lstlisting}[frame=single]
data Var a = B | F a
newtype Scope f a = Scope { fromScope :: f (Var a) }

instance Monad f => Monad (Scope f) where
  return = Scope . return . F
  Scope m >>= f = Scope $ m >>= varAppWithDefault (return B) (fromScope . f)

instance MonadTrans Scope where
  lift = Scope . liftM F

\end{lstlisting}


Теперь мы можем написать общие функции абстрагирования по переменной и подстановки в самую внешнюю переменную терма.


\begin{lstlisting}[frame=single]
abstract :: (Functor f, Eq a) => a -> f a -> Scope f a
abstract x xs = Scope (fmap go xs) where
  go y = y <$ guard (x /= y)

instantiate :: Monad f => f a -> Scope f a -> f a
instantiate x (Scope xs) = xs >>= go where
  go B = x
  go (F y) = return y

\end{lstlisting}


При кодогенерации нам всего лишь понадобится определить гораздо более простую монаду подстановок для ADT термов, которые выглядят теперь так:


\begin{lstlisting}[frame=single]
data Term a
  = Var a
  | App (Term a) (Term a) (Scope Term a)
  | Lam (Term a) (Scope Term a)

instance Monad Term where
  Var v1 >>= f = f v1
  App v1 v2 >>= f = App (v1 >>= f) (v2 >>= f)
  Lam v1 v2 >>= f = Lam (v1 >>= f) (v2 >>>= f)

(>>>=) :: (Monad f) => Scope f a -> (a -> f b) -> Scope f b
m >>>= f = m >>= lift . f
\end{lstlisting}


Этот метод использован в библиотеке bound\cite{bound}. В виду того, что нам часто приходится заходить внутрь контекстов (это необходимо при приведении в нормальную форму), обобщенные индексы де Брейна используемые в bound нам не подходят. Это связано с тем, что мы не можем просто сопоставлять с образцом, нам нужно вызывать функцию fromScope, которая работает нетривиально. При реализации описанной выше fromScope соответствует паттерматчингу на терме.
