\subsection{Вывод типов и нормализация}\label{nf_infer}
Сам infer работает как описано в Разделе~\ref{typecheck}. Мы последовательно строим каждую предпосылку и вызываем функцию вывода типов или проверки типа выражения на равенство типу. Термы, которые мы передаем в эти функции, строим последовательно на основе переданных нам в конструкции или полученных при вызове функции вывода типов (подробно описано в Разделе~\ref{build_exp}).

\begin{lstlisting}[caption={Пример правила вывода и части сгенерированной функции infer, соответствующей этому правилу},captionpos=b, frame=single, float, floatplacement=H]
If-then =
    forall t : tm, t1 : tm, t2 : tm, x.A : ty
      x : bool |- A def,   -- (1)
      |- t1 : A[x:=true],  -- (2)
      |- t2 : A[x:=false], -- (3)
      |- t : bool          -- (4)
      |-------------------------------
      |- if(x.A, t, t1, t2) : A[x:=t]

infer ctx (If v1 v2 v3 v4) = do
     -- check (4) ------------------------------------------
     v5 <- infer ctx v2
     checkEq Bool v5
     -- check (3) ------------------------------------------
     v6 <- infer ctx v4
     checkEq (instantiate False (toScope (fromScope v1))) v6
     -- check (2) ------------------------------------------
     v7 <- infer ctx v3
     checkEq (instantiate True (toScope (fromScope v1))) v7
     -- check (1) ------------------------------------------
     checkT ctx TyDef Bool
     checkT (consCtx Bool ctx) TyDef (fromScope v1)
     -- return ---------------------------------------------
     pure (instantiate v2 (toScope (fromScope v1)))
\end{lstlisting}

Стоит отметить, что порядок или количество переменных метапеременных, которые нам переданы, могут отличаться от порядка и вида контекста, в котором наша метапеременная должна быть в момент её использования. Эту проблему мы решаем приводя метапеременные к контексту данному в секции forall нашего правила вывода методом, описанным в Секции~\ref{build_exp}.

\begin{lstlisting}[caption={Искусственный пример случая несоответствия контекстов: контекст t нужно сократить до использования в предпосылке.},label={FRule},captionpos=b, frame=single, float, floatplacement=H]
FRule =
    forall S : ty, t : tm, T : ty
      x:S, y:S |- t : T, -- (1)
      x:T |- t : bool,   -- (2)
      |- gf(S, (x z).rf(T, (y r).T)) : rf(S, (x z).T) -- (3)
      |-----------------
      |- ff(S, t) def

 infer :: (Show a, Eq a) => Ctx a -> Term a -> TC (Type a)
 infer ctx (Ff v1 v2) = do
     -- check (1) -----------------------------------------
     checkT ctx TyDef v1
     checkT (consCtx v1 ctx) TyDef (rt add1 v1)
     v3 <- infer (consCtx (rt add1 v1) (consCtx v1 ctx))
             (rt add1 (rt add1 v2))
     -- check (3) -----------------------------------------
     v4 <- pure (nf v3) >>= traverse rem1 >>= traverse rem1
     v5 <- infer ctx
             (Gf v1
                (toScope2
                   (Rf (rt add1 (rt add1 v4))
                      (toScope2 (rt add1 (rt add1 (rt add1 (rt add1 v4))))))))
     checkEq (Rf v1 (toScope2 (rt add1 (rt add1 v4)))) v5
     -- check (2) -----------------------------------------
     checkT ctx TyDef v4
     v6 <- infer (consCtx v4 ctx) (rt add1 v2)
     checkEq Bool v6
     -- return --------------------------------------------
     pure TyDef
\end{lstlisting}

Функция nf пытается сопоставиться с образцом на терме, если это не выходит, то данная редукция неприменима. Поэтому нужен способ отслеживать какие редукции уже были опробованы, а какие нет. Это делается с помощью специальной структуры данных Cnt, описанной во вставке~\ref{lst_nf}. Эта структура служит в качестве целого числа, которое мы инициализируем количеством редукций применимых к нашей кострукции языка, и каждая несовпавшая редукция вызывает функцию nf c меньшим и меньшим числом, если же мы доходим до нуля, то мы истощили набор применимых редукций --- а значит терм находится в нормальной форме.

Стоит отметить, что такое сопоставление с образцом невозможно с использованием библиотеки bound\cite{bound}, поэтому был написан модуль SimpleBound c обычными, а не обобщенными, индексами де Брейна.

\begin{lstlisting}[caption={Приведение в нормальную форму пытается применить все редукции данного функционального символа},captionpos=b, frame=single, float, floatplacement=H, label={lst_nf}]
data Cnt = Bot | U (Cnt)
  deriving(Eq, Show)

nf :: (Show a, Eq a) => Term a -> Term a
nf (If v1 v2 v3 v4)
  = nf' (U (U Bot)) (If (nf1 v1) (nf v2) (nf v3) (nf v4))

nf':: (Show a, Eq a) => Cnt -> Term a -> Term a
nf' (U (U _)) al@(If (Scope v1) True v2 v3)
  = case
      do v4 <- pure v1
         v5 <- pure v2
         v6 <- pure v3
         pure v5
      of
        Left _ -> nf' (U Bot) al
        Right x -> nf x
nf' (U _) al@(If (Scope v1) False v2 v3)
  = case
      do v4 <- pure v1
         v5 <- pure v2
         v6 <- pure v3
         pure v6
      of
        Left _ -> nf' Bot al
        Right x -> nf x
nf' _ x = x
\end{lstlisting}
