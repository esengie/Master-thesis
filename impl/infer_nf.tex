\pagebreak
\subsection{Вывод типов и нормализация}\label{nf_infer}
Сам infer работает как описано в Разделе~\ref{typecheck}. Мы последовательно строим каждую предпосылку и вызываем функцию вывода типов или проверки типа выражения на равенство типу. Термы, которые мы передаем в эти функции, строим последовательно на основе переданных нам в функциональном символе или полученных при вызове функции вывода типов (подробно описано в Разделе~\ref{build_exp}).

\begin{lstlisting}[caption={Пример правила вывода и части сгенерированной функции infer, соответствующей этому правилу},captionpos=b, frame=single, float, floatplacement=H]
If-then =
    forall t : tm, t1 : tm, t2 : tm, x.A : ty
      x : bool |- A def,
      |- t1 : A[x:=true],
      |- t2 : A[x:=false],
      |- t : bool
      |-------------------------------
      |- if(x.A, t, t1, t2) : A[x:=t]

infer ctx (If v1 v2 v3 v4)
  = do v5 <- infer ctx v2
       checkEq Bool v5
       v6 <- infer ctx v4
       checkEq (instantiate False (toScope (fromScope v1))) v6
       v7 <- infer ctx v3
       checkEq (instantiate True (toScope (fromScope v1))) v7
       checkT ctx TyDef Bool
       checkT (consCtx Bool ctx) TyDef (fromScope v1)
       infer ctx v2
       infer ctx v3
       infer ctx v4
       pure (instantiate v2 (toScope (fromScope v1)))
\end{lstlisting}

Стоит отметить, что порядок или количество переменных метапеременных, которые у нас есть, могут отличаться от порядка и вида контекста, в котором наша метапеременная должна быть. Эту проблему мы решаем приводя метапеременные к контексту данному в секции forall нашего правила вывода методом, описанным в Секции~\ref{build_exp}.


\begin{lstlisting}[caption={Искусственный пример случая несоответствия контекстов: контекст t нужно сократить до использования в предпосылке.},label={FRule},captionpos=b, frame=single, float, floatplacement=H]
FRule =
    forall S : ty, t : tm, T : ty
      x:S, y:S |- t : T,
      x:T |- t : bool,
      |- gf(S, (x z).rf(T, (y r).T)) : rf(S, (x z).T)
      |-----------------
      |- ff(S, t) def

 infer ctx (Ff v1 v2) = do
     checkT ctx TyDef v1
     checkT (consCtx v1 ctx) TyDef (rt add1 v1)
     v3 <- infer (consCtx (rt add1 v1) (consCtx v1 ctx))
             (rt add1 (rt add1 v2))
     v4 <- pure (nf v3) >>= traverse rem1 >>= traverse rem1
     v5 <- infer ctx
             (Gf v1
                (toScope2
                   (Rf (rt add1 (rt add1 v4))
                      (toScope2 (rt add1 (rt add1 (rt add1 (rt add1 v4))))))))
     checkEq (Rf v1 (toScope2 (rt add1 (rt add1 v4)))) v5
     checkT ctx TyDef v4
     v6 <- infer (consCtx v4 ctx) (rt add1 v2)
     checkEq Bool v6
     infer ctx v2
     pure TyDef
\end{lstlisting}


Функция nf пытается сопоставиться с образцом на терме, если это не выходит, то данная редукция неприменима. Стоит отметить, что такое сопоставление с образцом невозможно с использованием библиотеки bound\cite{bound}, поэтому был написан модуль SimpleBound c обычными, а не обобщенными, индексами де Брейна.


\begin{lstlisting}[caption={Приведение в нормальную форму пытается применить все редукции данного функционального символа},captionpos=b, frame=single, float, floatplacement=H]
nf (If v1 v2 v3 v4)
  = nf' (U (U Bot)) (If (nf1 v1) (nf v2) (nf v3) (nf v4))

nf' (U (U _)) al@(If (Scope v1) True v2 v3)
  = case
      do v4 <- pure v1
         v5 <- pure v2
         v6 <- pure v3
         pure v5
      of
        Left _ -> nf' (U Bot) al
        Right x -> nf x
nf' (U _) al@(If (Scope v1) False v2 v3)
  = case
      do v4 <- pure v1
         v5 <- pure v2
         v6 <- pure v3
         pure v6
      of
        Left _ -> nf' Bot al
        Right x -> nf x
nf' _ x = x
\end{lstlisting}
