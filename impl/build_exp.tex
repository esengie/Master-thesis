\subsection{Построение термов}\label{build_exp}

Внутри кодогенерации функций nf и infer мы должны уметь строить термы языка, который мы проверяем/редуцируем. В функции infer это связано с тем, что при проверке предпосылок и возврате типа конструкции мы должны уметь строить произвольные термы специфицированного языка. В функции nf это связано с тем, что правая часть редукции может содержать произвольные термы языка.

Итак, на данной стадии работы алгоритма у нас имеется ассоциативный массив сопоставляющий метаперенные с выражениями на Haskell, которые им соответствуют (это всегда просто переменные языка). Рассмотрим дальнейший ход действий на примере. Предположим дана аксиома ff (см. вставку~\ref{ffrulee}).

\begin{lstlisting}[label={ffrulee}, caption={Искусственное правило вывода для конструкции ff},captionpos=b, frame=single, float, floatplacement=H]
FRule =
    forall S : ty, t : tm, T : ty
      x:S, y:S |- t : T,
      x:T |- t : bool,
      |- gf(S, (x z).rf(T, (y r).T)) : rf(S, (x z).T)
      |-----------------
      |- ff(S, t) def
\end{lstlisting}

На момент вызова у нас есть S и t в пустом контексте. Мы уже отсортировали предпосылки по трем группам описанным в~\ref{repr}. Сперва нам нужны предпослыки вводящие метапеременные. Поэтому первой предпосылкой которую мы проверяем является \lstinline{x:S, y:S |- t : T}. Чтобы поучить терм T мы должны вызвать функцию вывода типов в контексте, который нам передан, расширенном двумя вхождениями типа S. Ещё мы должны проверить, что эти расширения определены, то есть вызывать функции infer в постепенно увеличивающихся контекстах с термом, который мы хотим добавить в контекст в качестве аргумента.

Для этого мы должны расширить контекст терма t. Это является ограничением, наложенным на нас нашим же представлением, так как иначе у нас не сойдутся типы. Также могло случится так, что мы должны были бы переставить наши переменные в контексте.

Затем, получив нашу переменную в увеличенном контексте (в forall она имеет контекст меньшей длины), до того как мы добавим переменную, которая является её представителем в коде Haskell, мы должны уменьшить её контекст до того, что указан в forall\footnote{Не обязателен тот же порядок контекста, тк мы все равно о нём заботимся во время построения термов, то есть мы можем хранить в массиве представление метапеременной (z y x).T вместо (x y z).T. Главное чтобы это было указано в структуре, которую мы храним.}.

Затем мы проверяем вторую предпослыку, аналогично описанному выше способу. В третей предпосылке мы должны строить терм \lstinline{gf(S, (x z).rf(T, (y r).T))}. Это делается рекурсивно внутри монады кодогенерации, чтобы мы имели доступ к нашему ассоциативному массиву метапеременных. В данном примере нам потребуется из x.T получить (x z).T и (x z y r).T. Затем все аналогично.

Но при получении типа мы должны проверить его на равенство типу  \lstinline{rf(S, (x z).T)}. Который мы строим аналогично предыдущему описанию, затем вызываем функцию проверки равенства типов, на терме полученном при выводе типа \lstinline{gf(S, (x z).rf(T, (y r).T))} и построенном из метапеременных терма \lstinline{rf(S, (x z).T)} (см. вставку~\ref{FRule}).

\hfill

Одной из проблем индексов де Брейна является их жесткая привязка к порядку переменных в контексте. Действительно чтобы переставить аргументы терма \lstinline{[Lam ``y'' (Lam ``x'' (App ``x'' (App ``y'' (App ``y'' ``y''))))]} мы всего лишь меняем их местами в моменты их связывания и получаем \lstinline{[Lam ``x'' (Lam ``y'' (App ``x'' (App ``y'' (App ``y'' ``y''))))]}. Однако схожая операция для представления c использованием индексов де Брейна выливается в обход всего терма(!) \lstinline{[Lam (Lam (App 1 (App 2 (App 2 2))))]} превращается в \lstinline{[Lam (Lam (App 2 (App 1 (App 1 1))))]}.

Но если уж пользователь так написал спецификацию, что мы имеем терм с другим порядком переменных или терм с большим их количеством, то мы должны поменять эти переменные местами и даже попытаться удалить лишние переменные.

Например, чтобы привести ``(x y z).T'' к ``(z x).T''. Мы должны удалить ``y'' и переставить ``x'' и ``z'' местами.

Так же мы поступаем при возможном расширении контекста нашей метапеременной, например имеем ``S'' и хотим построить ``Lam A x.S'' --- здесь нужна метапеременная ``x.S'', мы получаем её добавляя переменную в её контекст.

Решение предлагаемое в данной работе состоит из композиций операций \lstinline{swap_i'j}, \lstinline{remove_i} и \lstinline{add_i}. Каждая операция выполняет traverse терма, который мы меняем. Примеры во вставке~\ref{swrem}.

\begin{lstlisting}[label={swrem}, caption={Примеры функций},captionpos=b, frame=single, float, floatplacement=H]
swap1'2 :: Var (Var  a) -> Identity (Var (Var  a))
swap1'2 (B ) = pure (F (B ))
swap1'2 (F (B )) = pure (B)
swap1'2 x = pure x

rem2 :: Var (Var a) -> TC (Var a)
rem2 B = pure B
rem2 (F B) = Left "There is var at 2"
rem2 (F (F x)) = pure (F x)

add2 :: Var a -> Identity (Var (Var a))
add2 B = pure $ B
add2 (F x) = pure $ F (F x)
\end{lstlisting}

Решение не является оптимальным, так как можно пройти по всему терму единожды и применить все эти операции сразу, но сложность генерации/написания такого кода возрастает значительно.

Для решения этой задачи написан модуль Solver\footnote{Стоит отметить что функции swap, rem и add должны быть сгенерированы и для этого ведется подсчёт в монаде кодогенерации путем записи максимального индекса. Следовательно функция swap дороже, так как мы генерируем $C_2^i$ функций. Именно поэтому алгоритм пытается использовать как можно меньше разных функций.}.

По сути мы либо имеем больший контекст и из него получаем меньший, либо наоборот. Хотим делать меньше swap'ов.

Рассмотрим случай приведения большего контекста к меньшему, ``[x, y, z]'' к ``[y, x]''. Мы идем справа налево, так как наиболее близкая связанная переменная наиболее правая. Удаляем те переменные которых нет в контексте к которому мы хотим прийти, таким образом обеспечиваем меньше вызовов к разным функциям rem\footnote{Мы не можем удалить переменную из контекста, если она присутствует в терме. Монада TC обеспечивает обработку ошибок удаления.}. Затем просто применяем алгоритм insertion sort на оставшихся контекстах. На количестве сгенерированных функций swap это не отразится.







%--
