\subsection{Построение термов}\label{build_exp}
Одной из проблем индексов де Брейна является их жесткая привязка к порядку переменных в контексте. Действительно чтобы переставить аргументы терма \lstinline{[Lam "y" (Lam "x" (App "x" (App "y" (App "y" "y"))))]} мы всего-лишь меняем их местами в моменты их связывания и получаем \lstinline{[Lam "x" (Lam "y" (App "x" (App "y" (App "y" "y"))))]}. Однако схожая операция для представления c использованием индексов де Брейна выливается в обход всего терма(!) \lstinline{[Lam (Lam (App 1 (App 2 (App 2 2))))]} превращается в \lstinline{[Lam (Lam (App 2 (App 1 (App 1 1))))]}.

Но если уж пользователь так написал спецификацию, что мы имеем терм с другим порядком переменных или терм с большим их количеством, то мы должны поменять эти переменные местами и даже попытаться удалить лишние переменные.

Например чтобы привести "(x y z).T" к "(z x).T". Мы должны удалить "y" и переставить "x" и "z" местами.

Так же мы поступаем при возможном расширении контекста нашей метапеременной, например имеем "S" и хотим построить "Lam A x.S" --- здесь нужна метапеременная "x.S", мы получаем её добавляя переменную в её контекст.

Решение предлагаемое в данной работе состоит из композиций операций \lstinline{swap_i'j}, \lstinline{remove_i} и \lstinline{add_i}. Каждая операция выполняет traverse терма, который мы меняем. Примеры функций:
\begin{lstlisting}[frame=single]
swap1'2 :: Var (Var  a) -> Identity (Var (Var  a))
swap1'2 (B ) = pure (F (B ))
swap1'2 (F (B )) = pure (B)
swap1'2 x = pure x

rem2 :: Var (Var a) -> TC (Var a)
rem2 B = pure B
rem2 (F B) = Left "There is var at 2"
rem2 (F (F x)) = pure (F x)

add2 :: Var a -> Identity (Var (Var a))
add2 B = pure $ B
add2 (F x) = pure $ F (F x)
\end{lstlisting}

Решение не является оптимальным, так как можно пройти по всему терму единожды и применить все эти операции сразу, но сложность генерации/написания такого кода возрастает значительно.

Для решения этой задачи написан модуль Solver\footnote{Стоит отметить что функции swap, rem и add должны быть сгенерированы и для этого ведется подсчёт в монаде кодогенерации путем записи максимального индекса. Следовательно функция swap дороже, так как мы генерируем $C_2^i$ функций. Именно поэтому алгоритм пытается использовать как можно меньше разных функций.}.

По сути мы либо имеем больший контекст и из него получаем меньший, либо наоборот. Хотим делать меньше swap'ов.

Рассмотрим случай приведения большего контекста к меньшему, "[x, y, z]" к "[y, x]". Мы идем справа налево, так как наиболее близкая связанная переменная наиболее правая. Удаляем те переменные которых нет в контексте к которому мы хотим прийти, таким образом обеспечиваем меньше вызовов к разным функциям rem\footnote{Мы не можем удалить переменную из контекста, если она присутствует в терме. Монада TC обеспечивает обработку ошибок удаления.}. Затем просто применяем алгоритм insertion sort на оставшихся контекстах. На количестве сгенерированных функций swap это не отразится.







%--
