\subsection{Генерация кода}
Генерация кода происходит с использованием библиотеки haskell-src-exts\cite{src_exts}, которая дает нам функции генерации и манипуляции АСТ Haskell.

Так как большинство кода используемого для проверки не зависит от специфицированного языка, мы просто модифицируем написанный от руки модуль LangTemplate. В нем нужно определить функции приведения в нормальную форму и вывода типов. Также нужно определить тип данных термов и определить монадическое действие на типе данных термов.

Всё остальное либо генерируется с помощью Template Haskell\cite{TH} --- instance Traversable\cite{deriveFun}, Functor, Foldable (Foldable дает нам функцию toList, которая возвращает свободные переменные терма, Traversable позволяет применять функции swap, rem и add  к переменным обходя весь терм), либо написано от руки с вызовами функций nf или infer.

\begin{lstlisting}[caption={Проверка типов и контексты},captionpos=b, frame=single, float,floatplacement=H]
emptyCtx :: (Show a, Eq a) => Ctx a
emptyCtx x = Left $ "Variable not in scope: " ++ show x

consCtx :: (Show a, Eq a) => Type a -> Ctx a -> Ctx (Var a)
consCtx ty ctx B = pure (F <$> ty)
consCtx ty ctx (F a)  = (F <$>) <$> ctx a

checkT :: (Show a, Eq a) => Ctx a -> Type a -> Term a -> TC ()
checkT ctx want t = do
  have <- infer ctx t
  when (nf have /= nf want) $ Left $
    "type mismatch, have: " ++ (show have) ++ " want: " ++ (show want)
\end{lstlisting}

Представители классов Eq и Show получаются с помощью механизма DeriveEq1, DeriveShow1\cite{deriveCompat} --- так как Term имеет кайнд $* \rightarrow *$, для него можно определить только представителей высших классов\cite{prel_extras}. Затем мы просто пишем определения независящие от представления:

\begin{lstlisting}[caption={Определение представителей классов Eq и Show для представления АСТ}, captionpos=b, frame=single, float,floatplacement=H]
instance Eq a => Eq (Term a) where (==) = eq1
instance Show a => Show (Term a) where showsPrec = showsPrec1
\end{lstlisting}

%%
