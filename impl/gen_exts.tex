\subsection{Генерация кода}
Генерация кода происходит с использованием библиотеки haskell-src-exts\cite{src_exts}, которая дает нам функции генерации и манипуляции АСД Haskell.

В виду того, что мы выбрали представление в виде Индексов де Брейна с полиморфной рекурсией, большинство кода для работы с представлением языка и контекстами не зависит от самого языка. От нас требуется только генерация определений 4ех сущностей:
\begin{itemize}
\item Представления специфицированного языка
\item Представителя класса Monad для представления языка
\item Функции infer --- вывода типов терма
\item Функции nf --- приведения в нормальную форму/вычисления терма
\end{itemize}

Поэтому, мы просто модифицируем написанный от руки модуль LangTemplate.

Всё остальное либо генерируется с помощью Template Haskell\cite{TH} --- представители классов Traversable\cite{deriveFun}, Functor, Foldable (Foldable дает нам функцию toList, которая возвращает свободные переменные терма, Traversable позволяет применять функции swap, rem и add к переменным внутри терма), либо написано от руки с вызовами внутри себя функций nf или infer.

Например, именно так работает функция проверки типа: в неё передается контекст, тип и терм; функция вызывает infer от контекста и терма и затем сравнивает нормальные формы типа, переданного в качестве аргумента, и типа, полученного при помощи вызова функции infer (код функции написан во вставке~\ref{lst_checkT}).

\begin{lstlisting}[caption={Проверка типов и контексты},captionpos=b, frame=single, float,floatplacement=H, label={lst_checkT}]
emptyCtx :: (Show a, Eq a) => Ctx a
emptyCtx x = Left $ "Variable not in scope: " ++ show x

consCtx :: (Show a, Eq a) => Type a -> Ctx a -> Ctx (Var a)
consCtx ty ctx B = pure (F <$> ty)
consCtx ty ctx (F a)  = (F <$>) <$> ctx a

checkT :: (Show a, Eq a) => Ctx a -> Type a -> Term a -> TC ()
checkT ctx want t = do
  have <- infer ctx t
  when (nf have /= nf want) $ Left $
    "type mismatch, have: " ++ (show have) ++ " want: " ++ (show want)
\end{lstlisting}

Представители классов Eq и Show получаются с помощью механизма DeriveEq1, DeriveShow1\cite{deriveCompat} --- так как Term имеет вид $* \rightarrow *$, для него можно определить только представителей высших классов\cite{prel_extras}.

Затем мы просто пишем определения представителей, независящие от представления (см. вставку~\ref{lst_inst_eq})

\begin{lstlisting}[caption={Определение представителей классов Eq и Show для представления АСД}, captionpos=b, frame=single, float,floatplacement=H, label = {lst_inst_eq}]
instance Eq a => Eq (Term a) where (==) = eq1
instance Show a => Show (Term a) where showsPrec = showsPrec1
\end{lstlisting}

%%
