\subsection{Проверка корректного использования метапеременных}\label{toposort}
В секции~\ref{lang_spec} описывался язык и ограничения, налагаемые на спецификации.

Здесь описан алгоритм проверки использования метапеременных в контекстах других метапеременных. А если конкретнее --- проверки того, что метапеременные не используют метапеременных переданных правее в функциональном символе, который мы определяем.

Так как язык не обязывает пользователся явно передавать типы переменных метапеременных, используемых в функциональных символах, метапеременные могут быть не только аргументами определяемого функционального символа, но и типами термов предпосылок.

Вначале рассмотрим алгоритм в предположении того, что все метапеременные переданы нам в функциональный символ. Тогда единственные места, где должна проводится проверка --- это определения метапеременных. То есть предпосылки вида $x_1 : tm_1 \ldots x_k : tm_k  \vdash T$.

Давайте строить граф зависимости и проверять его на ацикличность. В предпосылке выше из $T$ будет исходить стрелки во все метапеременные $tm_i$.

Если же добавить предпослыки вида: $x_1 : tm_1 \ldots x_k : tm_k  \vdash t : T$, которые определяют $T$ и $t$, то мы ещё и добавляем стрелку из $t$ в $T$, так как $T$ используется в определении $t$.

Вообще говоря, все другие варианты линеаризуемы и можно проверять строгий порядок, а не частичный. Приведем последний возможный случай --- случай из-за которого введена топологическая сортировка --- $x_1 : tm_1 \ldots x_k : tm_k  \vdash tm : T$. Здесь мы ставим стрелки аналогично первому варианту, но сама метапеременная T не имеет фиксированной позиции в списке аргументов функционального символа из заключения.

Итак, мы построили граф зависимостей одних метапеременных от других. Для проверки корректности правила вывода мы делаем топологическую сортировку и проверяем, что наш граф является DAG'ом.

























%%%
