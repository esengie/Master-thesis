\subsection{Проверка корректного использования метапеременных}\label{toposort}
В Разделе~\ref{lang_spec} описывался язык и ограничения, налагаемые на спецификации.

Все правила вывода соответствуют конструкции, которую они описывают, и у каждой конструкции есть своё правило вывода. Правила вывода определяют корректность составления конструкции. Конструкция, определяемая правилом вывода, пишется в заключении. При проверке типов мы идем от заключения к предпослыкам, поэтому метапеременные внутри конструкции в заключении передаются в функцию проверки типов вместе с самой конструкцией.

Важно отметить, что язык не обязывает пользователя явно передавать все метапеременные, используемые в правиле вывода, внутри конструкции в заключении. Поэтому метапеременные могут быть не только аргументами определяемой конструкции, но и типами термов предпосылок, но ничем больше --- так как их попросту неоткуда будет взять при проверке типов.

Здесь описан алгоритм проверки использования метапеременных в контекстах других метапеременных при их определении. А если конкретнее --- проверки того, что метапеременные не используют метапеременных переданных правее в конструкции, которую мы определяем. Это связано с тем, что иначе может возникнуть цикличность в определениях метапеременных.

Общим способом отслеживания ацикличности зависимостей является построение графа зависимостей и проверка его на ацикличность. Ниже будет пояснено почему выбран именно этот способ. Этот алгоритм используется для проверки каждого правила вывода.

Итак, на шаге инициализации алгоритма добавляем все пары из отношения переменных ``переменная x находится правее переменной y'' ребрами в граф зависимостей переменных (это нужно для проверки ацикличности в дальнейшем).

Вначале рассмотрим алгоритм в предположении того, что все метапеременные переданы внутри конструкции.
Тогда единственные места, где должна проводится проверка --- это определения метапеременных. То есть предпосылки вида $x_1 : tm_1 \ldots x_k : tm_k  \vdash T$. В предпосылке выше из метапеременной $T$ будут исходить стрелки во все метапеременные $tm_i$.

Если же добавить в рассмотрение предпосылки вида: $x_1 : tm_1 \ldots x_k : tm_k  \vdash t : T$, которые определяют $T$ и $t$, то мы ещё и добавляем стрелку из $t$ в $T$, так как $T$ используется в определении $t$.

Вообще говоря, все варианты выше линеаризуемы и можно проверять строгий порядок, а не частичный. Приведем последний возможный случай --- случай из-за которого введен граф зависимостей --- $x_1 : tm_1 \ldots x_k : tm_k  \vdash tm : T$. Здесь мы ставим стрелки аналогично первому варианту, но сама метапеременная T не имеет фиксированной позиции в списке аргументов конструкции языка из заключения, так как $tm$ не является метапеременной, вводимой с помощью $T$.

Итак, мы построили граф зависимостей одних метапеременных от других. Для проверки корректности правила вывода мы делаем топологическую сортировку и проверяем, что наш граф является DAG'ом.























%%%
