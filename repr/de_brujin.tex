\subsubsection{Традиционные индексы де Брейна}\label{de_brujin}
Стоит отметить, что в работе подразумевается реализация языков программирования через непосредственное описание АСД на Haskell (для введение в Haskell можно прочитать книгу\cite{moronuki}).

При реализации функциональных языков одной из первых задач встающих перед программистом является выбор представления АСД. Также нужно описывать абстракцию выражения языка по переменной, подстановку в переменные выражения и проверку на равенство выражений, и многие задачи и ошибки в реализации связаны именно с этими операциями.

Одной из задач представления выражений является сравнение $\alpha$-эквивалентных выражений. \textit{$\alpha$-эквивалентными} называются выражения, которые отличаются только в именовании связанных переменных. Например, следующие три выражения $\alpha$-эквивалентны:

\begin{lstlisting}
lamb x y → y (x z)
lamb y x → x (y z)
lamb a b → b (a z)
\end{lstlisting}

Одним из возможных способов представления выражений является представление переменных в виде строк. С использованием такого подхода первый приведенное выше выражение записывается в виде \lstinline{[Lam ``x'' (Lam ``y'' (App ``y'' (App ``x'' ``z'')))]}. Проверка равенства этого выражения второму выражению \lstinline{[Lam ``y'' (Lam ``x'' (App ``x'' (App ``y'' ``z'')))]} не тривиальна.

Другой проблемой такого представления выражений является захват свободных переменных при подстановке. Предположим, мы подставляем первое выражение ниже в переменную ``z'' во втором.
\begin{lstlisting}
lamb x → y
lamb y → z
lamb y → lamb x → y = lamb y x → y
\end{lstlisting}

Очевидно, что подставлять в переменную так наивно нельзя, так как ``y'' стала связанной, хотя не была таковой в первоначальном выражении.

Ключевым замечанием является то, что переменные в функциональных языках являются ``указателями'' на место их связывания --- этаким индексом в контекст --- и не несут никакой дополнительной информации.

Результат использования этого наблюдения называется индексами де Брейна. А именно: для каждой связанной переменной мы просто пишем расстояние от неё до места её связывания.

Если переписать выражения из примера с $\alpha$-эквивалентностью выше, то для всех трёх выражений получим \lstinline{[lamb lamb → 1 (2 z)]}, и проверка на $\alpha$-эквивалентность превращается в обычную проверку на равенство.

В представлении с помощью индексов де Брейна решается проблема захвата свободных переменных, а именно:
\begin{lstlisting}
lamb → y
lamb → z
lamb → lamb → y = lamb lamb → y
\end{lstlisting}

Как видим ``y'' остался свободным.

Это представление значительно лучше удовлетворяет нашим требованиям разработчика языков. Мы перешли от
\lstinline{[Lam ``y'' (Lam ``x'' (App ``x'' (App ``y'' ``z'')))]} к \lstinline{[Lam (Lam (App 1 (App 2 ``z'')))]}.

Однако общей проблемой обоих представлений является нетипизированность переменных --- никто не контролирует построение выражений вида \lstinline{[Lam (Lam (App 123 (App 23 ``z'')))]} --- где индексы указывают за пределы возмонжных связываный. Решение этой проблемы описано в разделе~\ref{de_brujin_impl}.
