\subsection{Традиционные индексы де Брейна}\label{de_brujin}
При реализации функциональных языков одной из первых проблем встающих перед программистом является выбор представления АСТ\footnote{В работе подразумевается реализация языков программирования через описание АСТ на Haskell.}. Также нужно описывать подстановки, и многие задачи и ошибки в реализации связаны с подстановками.

Одной из задач представления термов является сравнение $\alpha$-эквивалентных термов. \textit{$\alpha$-эквивалентными} называются термы, которые отличаются только в именовании связанных переменных. Например, следующие три терма $\alpha$-эквивалентны:

\begin{lstlisting}
lamb x y → y (x z)
lamb y x → x (y z)
lamb a b → b (a z)
\end{lstlisting}

Одним из возможных способов представления термов является представление переменных в виде строк. С использованием такого подхода первый приведенный выше терм записывается в виде \lstinline{[Lam ``x'' (Lam ``y'' (App ``y'' (App ``x'' ``z'')))]}. Проверка равенства этого терма второму терму \lstinline{[Lam ``y'' (Lam ``x'' (App ``x'' (App ``y'' ``z'')))]} не тривиальна.

Другой проблемой такого представления термов является захвата свободных переменных при подстановке. Предположим, мы подставляем первый терм ниже в переменную ``z'' во втором.
\begin{lstlisting}
lamb x → y
lamb y → z
lamb y → lamb x → y = lamb y x → y
\end{lstlisting}

Очевидно, что подставлять в переменную так наивно нельзя, так как ``y'' стала связанной, хотя не была таковой в первоначальном терме.

Ключевым замечанием является то, что переменные в функциональных языках являются ``указателями'' на место их связывания --- этаким индексом в контекст --- и не несут никакой дополнительной информации.

Результат использования этого наблюдения называется индексами де Брейна. А именно: для каждой связанной переменной мы просто пишем расстояние от неё до ближайшего связывания.

Если переписать термы с альфа эквивалентностью выше, то для всех трех термов получим \lstinline{[lamb lamb → 1 (2 z)]}, и проверка на альфа-эквивалентность превращается в проверку на равенство.

Также решается проблема захвата свободных переменных, а именно:
\begin{lstlisting}
lamb → y
lamb → z
lamb → lamb → y = lamb lamb → y
\end{lstlisting}

Как видно ``y'' остался свободным.

Это представление значительно лучше удовлетворяет нашим требованиям разработчика языков. Мы перешли от
\lstinline{[Lam ``y'' (Lam ``x'' (App ``x'' (App ``y'' ``z'')))]} к \lstinline{[Lam (Lam (App 1 (App 2 ``z'')))]}.

Однако общей проблемой обоих представлений является нетипизированность переменных --- никто не контролирует построение термов вида \lstinline{[Lam (Lam (App 123 (App 23 ``z'')))]}. Решение этой проблемы описано в секции~\ref{de_brujin_impl}.
