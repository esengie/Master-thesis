\subsubsection{Традиционные индексы де Брейна}\label{de_brujin}
Стоит отметить, что в работе подразумевается реализация языков программирования через непосредственное описание АСД на Haskell.

При реализации функциональных языков одной из первых задач встающих перед программистом является выбор представления АСД. Также нужно описывать абстракцию выражения языка по переменной, подстановку в переменные выражения и проверку на равенство выражений, и многие задачи и ошибки в реализации связаны именно с этими операциями.

Одной из задач представления выражений является сравнение $\alpha$-эквивалентных выражений. \textit{$\alpha$-эквивалентными} называются выражения, которые отличаются только в именовании связанных переменных. Например, следующие три выражения $\alpha$-эквивалентны:

\begin{lstlisting}
lamb x y → y (x z)
lamb y x → x (y z)
lamb a b → b (a z)
\end{lstlisting}

Одним из возможных способов представления выражений является представление переменных в виде строк. С использованием такого подхода первый приведенное выше выражение записывается в виде \lstinline{[Lam ``x'' (Lam ``y'' (App ``y'' (App ``x'' ``z'')))]}. Проверка равенства этого выражения второму выражению \lstinline{[Lam ``y'' (Lam ``x'' (App ``x'' (App ``y'' ``z'')))]} не тривиальна.

Другой проблемой такого представления выражений является захват свободных переменных при подстановке. Предположим, мы подставляем первое выражение ниже в переменную ``z'' во втором.
\begin{lstlisting}
lamb x → y
lamb y → z
lamb y → lamb x → y = lamb y x → y
\end{lstlisting}

Очевидно, что подставлять в переменную так наивно нельзя, так как ``y'' стала связанной, хотя не была таковой в первоначальном выражении.

Ключевым замечанием является то, что переменные в функциональных языках являются ``указателями'' на место их связывания --- этаким индексом в контекст --- и не несут никакой дополнительной информации.

Результат использования этого наблюдения называется индексами де Брейна. А именно: для каждой связанной переменной мы просто пишем расстояние от неё до места её связывания.

Если переписать выражения из примера с $\alpha$-эквивалентностью выше, то для всех трёх выражений получим \lstinline{[lamb lamb → 1 (2 ``z'')]}, и проверка на $\alpha$-эквивалентность превращается в обычную проверку на равенство.

При представлении с помощью индексов де Брейна также решается проблема захвата свободных переменных. Если переписать пример выше, использованный для объяснения этой задачи:
\begin{lstlisting}
lamb → y
lamb → z
lamb → lamb → y = lamb lamb → y
\end{lstlisting}

Как видно ``y'' остался свободным.

Это представление значительно лучше удовлетворяет нашим требованиям разработчика языков. Мы перешли от
\lstinline{[Lam ``y'' (Lam ``x'' (App ``x'' (App ``y'' ``z'')))]} к \lstinline{[Lam (Lam (App 1 (App 2 ``z'')))]}.

Однако общей проблемой обоих представлений является нетипизированность переменных --- никто не контролирует построение выражений вида \lstinline{[Lam (Lam (App 123 (App 23 ``z'')))]} --- где индексы указывают за пределы возможных связываний. Решение этой проблемы описано в разделе~\ref{de_brujin_impl}.
