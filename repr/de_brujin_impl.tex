\subsection{Индексы де Брейна на уровне типов}\label{de_brujin_impl}
В нашем описании индексов де Брейна в Cекции~\ref{de_brujin} мы упомянули, что наивное их использование склонно к ошибкам и не использует систему типов Haskell.

% Также если мы хотим работать внутри терма, минуя связывание мы должны обходить весь терм и обновлять значения всех индексов. Например при рассмотрении \lstinline{Lam (Lam 2)}, если мы хотим заглянуть внутрь связанного терма, мы должны уменьшить 

Эту проблему можно решить с помощью полиморфной рекурсии\cite{Bird:Pat}. По сути, каждый раз когда мы абстрагируемся по переменной в представлении де Брейна, мы добавляем единицу ко всем связанным переменным внутри терма. Ключевым наблюдением является то, что мы можем добавлять единицу оборачивая терм в Maybe. Например:

\begin{lstlisting}[frame=single]
data Term a
  = Var a
  | App (Term a) (Term a)
  | Lam (Term (Maybe a))
\end{lstlisting}

Однако этот метод не очень удобен при кодогенерации, так как instance Monad будет зависет от определения Term. В той же статье предложен способ превращения этого паттерна программирования в трансформер монад. В коде Maybe заменен на Var, в соответствии со своей семантикой, но других отличий нет. Также можно заметить, что Scope и есть трансформер монад MaybeT.

\begin{lstlisting}[frame=single]
data Var a = B | F a
newtype Scope f a = Scope { fromScope :: f (Var a) }

instance Monad f => Monad (Scope f) where
  return = Scope . return . F
  Scope m >>= f = Scope $ m >>= varAppWithDefault (return B) (fromScope . f)

instance MonadTrans Scope where
  lift = Scope . liftM F
\end{lstlisting}

Теперь мы можем написать общие функции абстрагирования по переменной и подстановки в самую внешнюю переменную терма.

\begin{lstlisting}[frame=single]
abstract :: (Functor f, Eq a) => a -> f a -> Scope f a
abstract x xs = Scope (fmap go xs) where
  go y = y <$ guard (x /= y)

instantiate :: Monad f => f a -> Scope f a -> f a
instantiate x (Scope xs) = xs >>= go where
  go B = x
  go (F y) = return y

\end{lstlisting}

При кодогенерации нам всего лишь понадобится определить гораздо более простую монаду подстановок для АСТ термов, которые выглядят теперь так:

\begin{lstlisting}[frame=single]
data Term a
  = Var a
  | App (Term a) (Term a) (Scope Term a)
  | Lam (Term a) (Scope Term a)

instance Monad Term where
  Var v1 >>= f = f v1
  App v1 v2 >>= f = App (v1 >>= f) (v2 >>= f)
  Lam v1 v2 >>= f = Lam (v1 >>= f) (v2 >>>= f)

(>>>=) :: (Monad f) => Scope f a -> (a -> f b) -> Scope f b
m >>>= f = m >>= lift . f
\end{lstlisting}

Этот метод использован в библиотеке bound\cite{bound}. В виду того, что нам часто приходится заходить внутрь связываний (это необходимо при приведении в нормальную форму), обобщенные индексы де Брейна используемые в bound нам не подходят. Это связано с тем, что мы не можем просто сопоставлять с образцом, нам нужно вызывать функцию fromScope, которая работает нетривиально. При реализации описанной выше fromScope соответствует сопоставлению с образцом на терме.

Использование полиморфной рекурсии для выражения индексов де Брейна имеет дополнительные преимущества:
\begin{itemize}
  \item Проверка корректности построения термов на уровне типов (невозможно написать терм Lam 123 в пустом контексте, так как $\lambda$ захватывает только одну переменную).
  \item Можно абстрагировать это представление, превратив Scope в трансформер монад. Тогда нам остается лишь определить представителя класса Monad для нашего представления термов (bind работает как подстановка), что делается крайне просто с точки зрения кодогенерации.
  \item Абстрактное представления дает нам обобщенные функции abstract и instantiate, которые абстрагируют переменную и инстанциируют самую внешнюю связную переменную соответственно. Таким образом решается проблема представления подстановок.
  \item С помощью механизма Deriving Haskell можно получить представителя классов Functor, Traversable и Foldable. Что дает нам функции toList --- список свободных переменных терма --- и traverse --- применить аппликативную функцию к переменным терма.
  \item Можно определить обобщенные Show и Eq --- не теряем простоты использования более простого представления без полиморфной рекурсии.
\end{itemize}
