\subsubsection{Индексы де Брейна на уровне типов}\label{de_brujin_impl}
В нашем описании индексов де Брейна в Cекции~\ref{de_brujin} мы упомянули, что наивное их использование склонно к ошибкам и не использует систему типов Haskell.

Эту проблему можно решить с помощью полиморфной рекурсии\cite{Bird:Pat}. По сути, каждый раз когда мы абстрагируемся по переменной в представлении де Брейна, мы добавляем единицу ко всем свободным переменным внутри терма. Ключевым наблюдением является то, что мы можем добавлять единицу оборачивая терм в Maybe. Например:

\begin{lstlisting}[frame=single]
data Term a
  = Var a
  | App (Term a) (Term a)
  | Lam (Term (Maybe a))
\end{lstlisting}

Стоит сказать, что, если добиться некоторой абстрактности представления, это позволит нам генерировать меньше кода. Идея состоит в определении для представлении термов представителя класса Monad, смыслом операции bind будет применение функций к переменным. Через неё можно выразить подстановку, при этом ниже будет показано, каким образом можно выделить связывания в свой модуль так, чтобы термы заботились только о подстановке в переменные, а связывания обрабатывались бы в коде этого модуля.

Поэтому метод выше не очень удобен при кодогенерации, так как функции подстановки и абстракции будут сильно зависеть от определения Term и нам придется генерировать много кода, специфичного для каждого представления (полный пример кода для данного представления можно увидеть на \url{github.com/esengie/cath_lec/blob/master/lec7/tasks7.hs}).

В той же статье предложен способ превращения этого паттерна программирования в трансформер монад. В последующем коде Maybe заменен на Var, в соответствии со своей семантикой, но отличие только в названии. Все представители классов у Var работают так же, как и у Maybe (Alternative, Functor, Monad и проч.). Также можно заметить, что Scope есть трансформер монад MaybeT (прочитать, как именно это работает для Maybe и MaybeT, можно в книге\cite{moronuki}).

\begin{lstlisting}[frame=single]
data Var a = B | F a
newtype Scope f a = Scope { fromScope :: f (Var a) }

instance Monad f => Monad (Scope f) where
  return = Scope . return . F
  Scope m >>= f = Scope $ m >>= varAppWithDefault (return B) (fromScope . f)

instance MonadTrans Scope where
  lift = Scope . liftM F
\end{lstlisting}

Теперь мы можем написать общие функции абстрагирования по переменной и подстановки в самую внешнюю переменную терма.
\begin{lstlisting}[frame=single]
abstract :: (Functor f, Eq a) => a -> f a -> Scope f a
abstract x xs = Scope (fmap go xs) where
  go y = y <$ guard (x /= y)

instantiate :: Monad f => f a -> Scope f a -> f a
instantiate x (Scope xs) = xs >>= go where
  go B = x
  go (F y) = return y
\end{lstlisting}

Функция abstract при совпадении с абстрагируемой переменной, пользуясь определением Alternative Var, возвращает B -- что означает связанную переменную. Иначе она, пользуясь определением Applicative Var, возвращает pure, что есть F, то есть повышает индекс переменной.

Функция instantiate просто подставляет в B переменную (так как она наиболее внешняя), иначе понижает индекс переменной.

Теперь при генерации кода нам всего лишь понадобится определить гораздо более простую монаду подстановок для АСД термов, а со связываниями разбирается наш трансформер Scope. Представление и представитель класса Monad, которое нужно генерировать, выглядят теперь так:

\begin{lstlisting}[frame=single]
data Term a
  = Var a
  | App (Term a) (Term a) (Scope Term a)
  | Lam (Term a) (Scope Term a)

instance Monad Term where
  Var v1 >>= f = f v1
  App v1 v2 >>= f = App (v1 >>= f) (v2 >>= f)
  Lam v1 v2 >>= f = Lam (v1 >>= f) (v2 >>>= f)

(>>>=) :: (Monad f) => Scope f a -> (a -> f b) -> Scope f b
m >>>= f = m >>= lift . f
\end{lstlisting}

Где оператор \lstinline{(>>>=)} работает как обычная композиция с lift нашего трансформера Scope.

Стотить отметить, что этот метод c некоторыми улучшениями использован в библиотеке bound\cite{bound}. В подходе выше нужно каждую переменную оборачивать в F индивидуально, в библиотеке использован способ оборачивания поддеревьев АСД терма.

Однако в нашем случае эта оптимизация неприменима, так как ещё одной задачей, которую должно решать представление --- является возможность сопоставления с образцом. Например, если у нас есть искусственная редукция вида $app[\lambda(A, x.\lambda(B, y.t)], r) => t[x:=r]$, в функции приведения в нормальную форму происходит сопоставление с образцом, а именно левая часть функции нормализации выглядит как-то так \lstinline{nf (App (Lam _ (Scope (Lam _ t))) r) = ...} --- основная важность этого примера в том, что наше представление позволяет заходить под связывание при сопоставлении с образцом, чего нет в библиотеке bound.
