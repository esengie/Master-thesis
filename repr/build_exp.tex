\subsubsection{Построение термов}\label{build_exp}
Одной из проблем индексов де Брейна является их жесткая привязка к порядку переменных в контексте. Действительно, чтобы переставить аргументы терма `\lstinline{Lam ``y'' (Lam ``x'' (App ``x'' (App ``y'' (App ``y'' ``y''))))}', нужно всего лишь поменять их местами в моменты связывания, и получаем `\lstinline{Lam ``x'' (Lam ``y'' (App ``x'' (App ``y'' (App ``y'' ``y''))))}'.

Однако схожая операция для представления c использованием индексов де Брейна выливается в обход всего терма(!), и `\lstinline{Lam (Lam (App 1 (App 2 (App 2 2))))}' превращается в `\lstinline{Lam (Lam (App 2 (App 1 (App 1 1))))}'. То есть, все единицы и двойки в терме поменялись местами.

Но пользователь мог так написать спецификацию языка, что в момент проверки типов или применения редукций у нас есть терм представляющий метапеременную с переставленным порядком переменных (или с большим или меньшим их количеством), чем в терме, который мы строим (пример такого правила обсуждается в Подразделе~\ref{nf_infer}). Тогда мы должны поменять эти переменные местами, добавить недостающие и даже попытаться удалить лишние переменные.

Разберем пример с удалением переменной, чтобы привести `(y z x).T' к `(y x).T' нужно удалить переменную `z'. Поясним удаление переменной подробнее, предположим нам дан терм `\lstinline{App ``x'' (App ``y'' (App ``y'' ``y''))}' в контексте `[y, z, x]', то есть нашей метаперемнной `(y z x).T' соответствует терм `\lstinline{App ``x'' (App ``y'' (App ``y'' ``y''))}', что в представлении с использованием индексов де Брейна превращается в `\lstinline{App 1 (App 3 (App 3 3))}'. При построении какого-то терма может понадобиться удалить вторую переменную --- для этого нужно понизить индексы связанные за ней на единицу, получим `\lstinline{App 1 (App 2 (App 2 2))}' --- терм соответствующий `(y x).T'. Однако, если удаляемая переменная есть внутри терма, построение терма вынуждено сообщить об ошибке.

При возможном расширении контекста метапеременной алгоритм сходен алгоритму удаления. Например, имеем `S' и требуется построить `Lam A x.S' --- здесь понадобится метапеременная `x.S', получаем её путем добавления единицы ко всем переменным которые являются связанными за ней.

Итак, предлагаемое решение состоит из композиций операций $swap_{i,j}$, $remove_i$ и $add_i$. Где индексы означают переменные, над которыми совершается операция.

Решение не является оптимальным, так как можно пройти по всему терму единожды и применить все эти операции сразу, но сложность генерации/написания такого кода возрастёт. Поэтому было принято решение остановиться на таком алгоритме, этот момент в реализации обладает потенциалом к оптимизации.

\hfill

Можно дать алгоритмические постановки этих двух задач --- уменьшения контекста и увеличения контекста --- абстрагировавшись от технических деталей, связанных с манипуляцией термов.

Формализуем задачу увеличения контекстов: при подаче на вход двух списков xs и ys таких, что все элементы xs находятся в списке ys, выдать две последовательности применений функций $swap_{i,j}$ и $add_i$ соответственно, которые нужно применить к xs (вначале все $swap_{i,j}$, затем все $add_i$), чтобы получить ys.

Постановка для удаления и перестановок дается аналогично.

Для решения этой задачи написан модуль Solver\footnote{Стоит отметить, что при генерации реализации языка функции $swap_{i,j}$, $remove_i$ и $add_i$ должны быть сгенерированы, и для этого ведется подсчёт в монаде кодогенерации путем записи максимального номера использованной функции. Именно поэтому алгоритм пытается использовать как можно меньше разных функций.}.

По сути, мы либо имеем больший контекст и из него получаем меньший, либо наоборот. В первом случае мы удаляем все переменные, которые нам не нужны оптимальным способом, затем приводим один контекст к другому аналогом сортировки вставками. Таким образом нам понадобится меньше операций swap. Во втором случае вначале производятся все опреции swap, затем добавляются все недостающие переменные, начиная с конца --- с конца по той же причине, что удаление идет в начало.

Рассмотрим случай приведения большего контекста к меньшему, `[x, y, z]' к `[y, x]'. Алгоритм идет справа налево, так как наиболее близкая связанная переменная наиболее правая. Удаляем те переменные, которых нет в контексте к которому мы хотим прийти, таким образом обеспечиваем меньше вызовов к разным функциям rem, так как при удалении первого элемента мы можем удалить следующий первый элемент и т.д. Затем просто применяем аналог алгоритма сортировки вставками на оставшихся контекстах --- находим первый элемент целевого контекста и ставим его на место, затем второй и т.д.

\hfill

Нужно ещё решить техническую сторону задачи манипуляций контекстами термов в генерируемом языке.

В представлении через индексы де Брейна с полиморфной рекурсией нам понадобится функция `traverse' терма, который подвергается изменениям. Она применяет аппликативную операцию ко всем внутренним элементам терма. Если определять представителя класса Traversible через механизм Deriving Haskell\cite{deriveFun}, то это превращается в обычный обход синтаксического дерева, с применением функции к переменным --- чего мы и хотим (более подробное описание представлено в~\cite{bound}). Примеры функций $swap_{i,j}$, $remove_i$ и $add_i$ приведены во вставке~\ref{swrem}.

Если посмотреть на вставку~\ref{swrem} внимательнее, можно заметить, что удаление переменной из терма, присутствующего в нем, приводит к ошибке. Монада Either обеспечивает обработку ошибок удаления.

Также можно отметить, раз у нас есть Traversable, то мы можем определить представителей Functor и Applicative через функций fmapDefault и foldMapDefault соответственно. Эти функции есть в классе Traversible.

\begin{lstlisting}[label={swrem}, caption={Примеры функций $swap_{i,j}$, $remove_i$ и $add_i$},captionpos=b, frame=single, float, floatplacement=H]
swap1'2 :: Var (Var  a) -> Identity (Var (Var  a))
swap1'2 (B ) = pure (F (B ))
swap1'2 (F (B )) = pure (B)
swap1'2 x = pure x

rem2 :: Var (Var a) -> Either String (Var a)
rem2 B = pure B
rem2 (F B) = Left "There is a var at 2"
rem2 (F (F x)) = pure (F x)

add2 :: Var a -> Identity (Var (Var a))
add2 B = pure $ B
add2 (F x) = pure $ F (F x)
\end{lstlisting}







%--
