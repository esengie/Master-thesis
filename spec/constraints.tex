\subsection{Ограничения на спецификации, налагаемые языком}\label{constraints}
Если рассматривать спецификации как произвольные существенно алгебраические теории, то пользователь может написать спецификацию, для которой мы не сможем сгенерировать функцию проверки типов. Поэтому вводятся следующие ограничения на спецификации языков:

\begin{enumerate}
\item Запрещено равенство в заключении аксиом для определенности каждого шага в проверке типов определяемого языка Это связано с тем, что, если мы видим равенство, не ясно в какую сторону идти при редуцировании. Поэтому мы обязываем пользователя пользваться редукциями.

\item Если в заключении аксиомы написан функциональный символ возвращающий сорт термов, он обязан также иметь тип (нельзя просто написать $ \vdash f(\ldots) def$). Так как иначе становится неясно какой тип возвращать при выводе типа данного функционального символа.

\item Определения функциональных символов всегда одно, иначе появляется недетерминированность в проверке типов. Не играет особой роли, так как в данном случае можно сделать недетерминированность в проверке. Однако в ходе эксплуатации не возникало нужды в обратном. Понадобилось бы более тщательное обдумывание последствий отсутствия данного ограничения. В будущем вохможны изменения.

\item Подстановки разрешены только в метапеременные --- в принципе, это слабое ограничение, которое облегчает жизнь при реализации, не ограничивая пользователя. Нам не нужно ещё и на метауровне заботиться о подстановках.

\item \label{tm:Meta} Все метапеременные, используемые в предпосылках, должны либо присутствовать в метапеременных заключения, или же должны быть типами какой-либо предпосылки. Иначе не ясно откуда брать эти метапеременные при проверке типов. Получается, что нужно будет считать, что высказывание с метапеременной верно для любого представителя сорта этой метапеременной.

\item Если в функциональном символе встречаются метапеременные с контекстами $x_1 \ldots x_k . T$ должна существовать предпосылка вида $x_1 : S_1 \ldots x_k : S_k  \vdash T$. Это сделано для того, чтобы не передавать типы контекстов метапеременных функционального символа явно, а выводить их из таких условий.

\item Если метапеременная является типом предпосылки и не встречается в аргументах функционального символа, то она может использоваться только справа от двоеточия. Таким образом избегаются ситуации связанные с порядком проверки предпосылок языка. А именно: если у нас есть $x : S \vdash t : T,\ x:T \vdash r : S$, то нужно строить граф зависимостей для предпосылок и использовать порядок полученный в результате его топологической сортировки в генерации кода. (Аналогично с~\ref{toposort}).

\item \label{order:Meta} Все переменные контекстов определения метапеременных могут использовать только метапеременные левее внутри функционального символа в заключении --- это связано с тем, что иначе могут возникнуть циклы в определениях метапеременных: S тип с аргументом типа R, R тип с аргументом типа S, S тип с аргументом типа R и т.д.

\item Из-за ослабления условия на метапеременные в Пункте~\ref{tm:Meta}, порядок метапеременных неочевиден. Решение данной проблемы и~(\ref{order:Meta}) описано в Разделе~\ref{toposort}.

\item Редукции не учитывают предпосылок при приведении в нормальную форму --- предполагается что они не конфликтуют с аксиомами и проверки в аксиомах достаточно.

\item В редукциях все метапеременные справа от '=>' должны встречаться и слева от него. Иначе непонятно откуда взять эти метаперемнные при формировании правой части редукции.

\item Подстановка запрещена слева от '=>'. Это сделано для возможности сопоставления с образцом при генерации функции приведения в нормальную форму.

\item Все редукции всегда стабильны. Иначе требует дальнейшего исследования, так как появится требование передачи контекста в функцию нормализации.

\item Все аргументы в функциональный символ в заключении аксиомы должны быть метапеременными --- случай содержащий не только метапеременные требует дальнейшего исследования. Ещё и с теми же контекстами, что и в forall (не расширенный контекст, не существенное ограничение).

\item В заключении контекст не должен быть расширен --- это ограничение связано с тем, что иначе смысл аксиомы становится странным. А именно: функциональный символ применим только при введении переменных в контекст.

\end{enumerate}

Также у нашего языка есть ограничения, налагаемые существенно алгебраическими теориями:
\begin{itemize}
\item Все используемые метапеременные должны иметь аннотацию (сорт), то есть присутствовать в секции forall аксиомы/редукции.
\item Мы явно специфицируем все сорты, которые используем.
\end{itemize}

\subsection{Проверки корректности спецификации языка}

Все ограничения выше проверяются при обработке спецификации языка.

Также тривиальными проверками, осуществляемыми после парсинга языка, являются:
\begin{itemize}
\item Все метапеременные, используемые в правилах вывода/редукциях находятся в контексте, включающем их контекст, описанный в секции forall.
\item Проверка того, что сорты используемых выражений совпадают с сортами аргументов функциональных символов.
\item Подстановка осуществляется в переменные, которые есть в свободном виде в метапеременной.
\item Контексты метапеременных содержат все их метапеременные.
\item Все функциональные символы имеют ассоциированное правило вывода.
\end{itemize}
