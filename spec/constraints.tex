\subsection{Ограничения на спецификации, налагаемые языком}\label{constraints}

Ниже перечислены все ограничения, вводимые нашим языком спецификации. Некоторые ограничения имеют смысл для всех языков c зависимыми типами, другие введены для практичности или простоты реализации. Каждое ограничение имеет свой номер для отсылок к нему в дальнейшем тексте.

\hfill

% Во многих случаях введение этих связано с простотой или практичностью реализации генерации кода.
Следующий блок ограничений --- ограничения вводимые нами на множество специфицируемых языков, которые могут и не выполнятся в произвольных формальных языках. При написании алгоритма проверки типов от руки эти ограничения нужно рассматривать индивидуально для каждого правила и принимать решения об их включении/исключении. Некоторые из ограничений могут быть сняты в языке спецификации, однако это потребовало бы дальнейшего, иногда значительно более глубокого изучения, эффекта на всю систему при его снятии.
\begin{enumerate}

\item \label{funsym_concl} В заключении правила вывода на верхнем уровне слева от отношения типизации может быть только конструкция языка. Не должно быть подстановок или метапеременных на верхнем уровне. Это связано с тем, что не ясно как работать с подстановками в заключениях правил вывода, так как на этапе проверки типов знание того, что ``нам передается что-то с выполненной в него подстановкой куда-то'', не дает нам никакой дополнительной информации, в сравнении с отсутствием этого знания. Также неясно, что делать с метапеременной, переданной в заключении, так как она будет подходить подо все выражения сорта этой метапеременной. Поэтому разрешены только конструкции языка в заключении.

\item \label{one_per_fun} Правило вывода для каждой конструкции всегда одно, иначе появляется недетерминированность в проверке типов --- неясно какое правило вывода выбрать. Если идти по всем возможным правилам сразу, то может произойти комбинаторный взрыв в сложных выражениях языка. Можно сравнить со случаем нескольких редукций: несколько редукций для конструкции работает, так как, если в редукция не применима, мы просто пытаемся применить следующую, а для правил вывода при ошибке проверки потребовалось бы подниматься на тот уровень, в котором было выбрано одно правило из нескольких и выбирать следующее. Также из-за этого вывод типов может стать неоднозначным --- может возникнуть ситуация с несколькими возможными типами терма. При снятии ограничения понадобилось бы более тщательное обдумывание последствий его отсутствия и алгоритм проверки изменился бы в более сложную сторону; например, он мог стать таким, как описано выше.

\item \label{const_metas} Все аргументы в конструкцию языка в заключении правила вывода должны быть метапеременными --- случай содержащий не только метапеременные и со снятым ограничением Пункта~\ref{one_per_fun} требует дальнейшего исследования. Стоить отметить, что такие правила никогда не встречались нам в формализациях языков в литературе.

\item Запрещено равенство в заключении правил вывода, они заменены редукциями. Связано с тем, что не очень понятно как работать с ненаправленными равенствами. Появилась бы неопределенность выбора направления --- по аналогии с $\eta$-экспансией и $\eta$-редукцией (обсуждение можно прочитать в~\cite{ncat:eta}).

\item Подстановка запрещена слева от `\lstinline{=>}'. Это сделано для возможности сопоставления с образцом при генерации функции приведения в нормальную форму. Также как и в Пункте~\ref{funsym_concl} не очень понятно, как восстанавливать исходную метапеременную до подстановки.


% \item Редукции не учитывают предпосылок при приведении в нормальную форму --- предполагается что они не конфликтуют с правилами вывода и проверок корректности выражений в правилах вывода достаточно. Можно расширить до полной пров
\suspend{enumerate}

\hfill

В этом блоке описаны ограничения, введённые языком спецификации для простоты реализации. Эти ограничения никак не ограничивают множество выразимых языков и введены просто для удобства разработчика.
\resume{enumerate}
\item Запрещено перекрытие переменных, которые уже есть в контексте. Это чисто стилистическое ограничение, которое не вносит никаких ограничений на сами языки.

\item Подстановки разрешены только в метапеременные --- в принципе, это слабое ограничение, которое облегчает жизнь при реализации, не ограничивая пользователя. Нам, как разработчикам, не нужно ещё и на уровне мета-языка (языка спецификации) заботиться о подстановках --- об этом заботится пользователь.

\item (Имеет смысл при наличии Пункта~\ref{const_metas}) метапеременные в конструкции в заключении правила вывода должны быть с теми же контекстами, что и в forall --- если бы контексты были шире, то в алгоритме проверки типов сразу же приходилось бы проверять выражения, соответствующие метапеременным, на возможность удаления лишних переменных.
\suspend{enumerate}

\hfill

Следующие ограничения имеет смысл вводить для всех языков вообще, иначе проверка типов становится невозможной:
\resume{enumerate}

\item Если в заключении правила вывода написана конструкция возвращающая сорт термов, она обязана быть проаннотирована типом (нельзя просто написать $ \vdash f(\ldots)\ def$). Так как иначе становится неясно какой тип возвращать при выводе типа данной конструкции.

\item \label{tm:Meta} Все метапеременные, используемые в предпосылках, должны либо присутствовать в метапеременных заключения, или же должны быть типами какой-либо предпосылки. Иначе попросту неясно откуда брать выражения, соответствующие этим метапеременным, при проверке типов языка.

\item В редукциях все метапеременные справа от `\lstinline{=>}' должны встречаться и слева от него. Иначе непонятно откуда взять выражения соответствующие этим метаперемнным при формировании правой части редукции.

\item \label{right::} Если метапеременная является типом предпосылки и не встречается в аргументах конструкции, то она может использоваться только справа от двоеточия. Таким образом избегаются ситуации связанные с порядком проверки предпосылок языка. А именно: если у нас есть $x : S \vdash t : T,\ x:T \vdash r : S$, то нужно строить граф зависимостей для предпосылок и использовать порядок, полученный в результате его топологической сортировки, в генерации кода (Аналогично с~\ref{toposort}). Эту модификацию необходимо реализовать в языке, тогда ограничение поменяется на условие ацикличности графа зависимостей.
\suspend{enumerate}

\hfill

Этот блок ограничений связан с тем, что язык не обязывает пользователя передавать типы всех переменных контекстов метапеременных. Так как в большинстве случаев, которые мы встречали это привело бы к дублированию информации. Приведём пример с конструкцией $if$, в типизированном варианте она записывается так $if(t, x.F, a, b)$ --- при прочтении правила вывода нам ясно, что тип ``x'' это Bool. В нашем языке это можно вывести из предпосылки для ``x.F''. Таким же образом типы переменных в контексте могут быть и метапеременными. Поэтому для возможности передачи меньшего числа аргументов вводятся следующие ограничения:

\resume{enumerate}
\item \label{def_metas} Если в заключении правила вывода во вводимой конструкции языка встречаются метапеременные с контекстами $x_1 \ldots x_k . T$, то должна существовать предпосылка вида $x_1 : S_1 \ldots x_k : S_k  \vdash T$ в правиле вывода конструкции. Предпосылки такого вида мы называем \textit{определениями метапеременной}.
% Это сделано для того, чтобы не передавать типы контекстов метапеременных в конструкции явно, а выводить их из такого рода предпосылок.

\item \label{order:Meta} Все переменные контекстов определения метапеременных (то есть предпосылки, описанные в Пункте~\ref{def_metas}) могут использовать только метапеременные, переданные левее внутри конструкции в заключении, --- это связано с тем, что иначе могут возникнуть циклы в определениях метапеременных: S тип с аргументом типа R, R тип с аргументом типа S, S тип с аргументом типа R и т.д. Что приведет к зацикливанию функции проверки типов.

\item Из-за ослабления условия на метапеременные в Пункте~\ref{tm:Meta}, порядок метапеременных неочевиден. Решение данной проблемы и проверки ограничения в Пунтке~\ref{order:Meta} описано в Разделе~\ref{toposort}.
\suspend{enumerate}

\hfill

Также есть ещё одно ограничение языка, не принадлежащая к другим блокам:
\resume{enumerate}
\item В заключении контекст не должен быть расширен --- это ограничение связано с тем, что иначе смысл правила вывода становится странным. А именно: конструкция применима только при введении переменных в контекст.
\end{enumerate}



\subsection{Проверки корректности спецификации языка}

Все ограничения выше проверяются при обработке спецификации языка.

Также тривиальными проверками, осуществляемыми после синтаксического разбора языка, являются:
\begin{itemize}
\item Все метапеременные, используемые в правилах вывода/редукциях находятся в контексте, включающем их контекст, описанный в подразделе forall.
\item Проверка того, что сорты используемых выражений совпадают с сортами аргументов конструкций.
\item Подстановка осуществляется в переменные, которые есть в свободном виде в метапеременной.
\item Контексты метапеременных содержат все их переменные.
\item Все конструкции языка имеют ассоциированное правило вывода.
\end{itemize}
