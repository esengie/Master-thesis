Как мы уже писали в Разделе~\ref{deptypes_intro}, языки с зависимыми типами обычно задаются через правила вывода. Ниже представлены правила вывода для языка Bool c зависимыми типами.

\begin{center}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash Bool$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\Gamma \vdash True : Bool$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\Gamma \vdash False : Bool$}
\DisplayProof
\end{center}

\medskip

\begin{center}
\AxiomC{$\Gamma, x : Bool \vdash T$}
\AxiomC{$\Gamma \vdash t : Bool$}
\AxiomC{$\Gamma \vdash a : T[x:=True]$}
\AxiomC{$\Gamma \vdash b : T[x:=False]$}
\QuaternaryInfC{$\Gamma \vdash if(t, T, a, b) : T[x:=t] $}
\DisplayProof
\end{center}

Для полноты определения языка нужно определить правила для работы с контекстами и правила эквивалентности типов:

\begin{center}
\AxiomC{}
\UnaryInfC{$\vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash A$}
\RightLabel{, $x \notin \Gamma$}
\UnaryInfC{$\Gamma, x : A \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash$}
\RightLabel{, $x : A \in \Gamma$}
\UnaryInfC{$\Gamma \vdash x : A$}
\DisplayProof
\end{center}

\medskip

\begin{center}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash A \equiv B$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\begin{figure}[!h]
\caption{Правила, которые мы считаем верными во всех языках}
\label{always_right}
\end{figure}
\end{center}

Эти четыре правила всегда верны во всех языках, которые мы встречали в литературе, поэтому у нас они верны по умолчанию и их не нужно указывать в языке спецификации. Также подразумевается рефлексивность, симметричность, транзитивность и конгруэнтность равенства.

После описания правил вывода, если мы хотим описать, как этот язык вычислять, мы записываем правила редукции. Ниже представлены оба правила редукции для языка Bool.

\begin{center}
\AxiomC{$\Gamma, x : Bool \vdash T$}
\AxiomC{$\Gamma \vdash a : T[x:=True]$}
\AxiomC{$\Gamma \vdash b : T[x:=False]$}
\TrinaryInfC{$\Gamma \vdash if(True, T, a, b) \equiv a : T[x:=True]$}
\DisplayProof
\end{center}

\medskip

\begin{center}
\AxiomC{$\Gamma, x : Bool \vdash T$}
\AxiomC{$\Gamma \vdash a : T[x:=True]$}
\AxiomC{$\Gamma \vdash b : T[x:=False]$}
\TrinaryInfC{$\Gamma \vdash if(False, T, a, b) \equiv a : T[x:=False]$}
\DisplayProof
\end{center}

Чем более явно все описано/аннотировано, тем легче реализовывать язык. Поэтому было принято решение типизировать язык спецификации. Чтобы отличать метатипы (типы мета-языка) от типов специфицируемого языка, они носят название \textit{сортов}. В любом языке явно выделяются сорты, которые могут зависеть от термов, и сорты простые.

\hfill

Теперь опишем язык Bool в языке спецификации.

Спецификация имеет следующие разделы: простые cорты (может отсутствовать), зависимые сорты, конструкции, правила вывода и редукции.

Сперва пользователь должен описать все зависимые и независимые сорты. Термы всегда могут зависеть от термов, поэтому они всегда находятся в разделе зависимых сортов (термы имеют специальный идентификатор `tm'). Типы могут быть зависимыми, могут быть и независимыми, это происходит по выбору пользователя (идентификатор `ty'). Например, в языке Bool выше мы сделали выбор --- типы зависимые. Также в языке спецификации есть возможность вводить дополнительные сорты, нужные пользователю ---  в языке Bool это не понадобится.

Затем пользователь задает конструкции, для этого он описывает сорты каждого из аргументов и количество переменных, которые этот аргумент связывает. Затем он пишет сорт возвращаемого выражения.

На вставке~\ref{lst_bool_funs} представлена частичная спецификация языка Bool. Запись `(сорт, n)' --- описывает сорт и связывание аргумента, то есть у этого аргумента может в контексте быть на $n$ переменных больше, чем в контексте, где наша конструкция используется.

Привычным примером конструкции со связыванием служит $\lambda$-абстракция из нетипизированного $\lambda$-исчисления, эта конструкция имеет такую сигнатуру $(tm, 1) \rightarrow tm$ в языке спецификации, так как связывает дополнительную переменную внутри себя --- термы внутри конструкции $\lambda$ могут иметь контекст на одну переменную шире, чем снаружи.

\begin{lstlisting}[label={lst_bool_funs}, caption={Конструкции и сорты языка Bool, описанные в языке спецификации},captionpos=b, frame=single, float]
DependentSorts:
  tm, ty
FunctionalSymbols:
  if: (tm, 0)*(ty, 1)*(tm, 0)*(tm,0) -> tm
  bool: ty
  true : tm
  false : tm
\end{lstlisting}

После этого пользователь должен задать правила вывода, по одной на каждую конструкцию (причина объяснена в Разделе~\ref{constraints}, в Пункте~\ref{one_per_fun}).

\textit{Правилом вывода конструкции} --- называется правило вывода такое, что в его заключении наиболее внешней является конструкция ей соответсвуюшая. В языке Bool есть по одному правилу вывода на каждую конструкцию.

В языке спецификации каждое правило вывода и редукция начинаются с подраздела forall, в котором пользователь описывает сорты всех метапеременных, которые он будет использовать в правиле вывода/редукции. В этом подразделе требуется именование каждой дополнительной переменной, которая может находится в контексте метапеременной. Это сделано для возможности коррекции простых ошибок пользователя --- например использование метапеременных в меньшем контексте, чем он должен быть.

Явное указание увеличенных контекстов метапеременных позволяет проверять наличие нужных переменных в контексте, в котором они используются. А указание сортов --- корректность применения функциональных символов. Стоит отметить, что в подразделе forall указывается минимальный набор переменных в контексте метапеременной, то есть все эти переменные всегда должны находится в контексте метапеременной, на момент её использования, однако контекст может быть и шире.

Далее в определении правила вывода идет описание предпосылок и заключения, также как и в описании через обычные правила вывода, которое мы писали выше.

\begin{lstlisting}[label={lst_bool_axs}, caption={Правила вывода языка Bool, описанные в языке спецификации},captionpos=b, frame=single, float]
Axioms:
  T-Bool =
    |--- |- bool def
  T-Fls =
    |--- |- false : bool
  T-Tr =
    |--- |- true : bool
  T-If =
    forall x.T : ty, t : tm, a : tm, b : tm
      |- t : bool, x : bool |- T def,
      |- a : T[x:=true], |- b : T[x:=false]
      |---------------------------------------
      |- if(t, x.T, a, b) : T[x:=t]
\end{lstlisting}

(Стоить отметить, что отступы в языке значительны, а именно, названия правила вывода должны быть на уровень ниже названия раздела, подраздел forall на уровень ниже названия, суждения на уровень ниже подраздела forall (если её нет --- на уровень ниже имени)). Давайте разберем нотацию вставки~\ref{lst_bool_axs}.

Черта в языке спецификации заменена на `\lstinline{|---}', количество дефисов от трёх и больше. Это сделано для удобства пользователя, во вставке можно увидеть оба предполагаемых варианта использования. Предпосылки записываются через запятую, запись `$\_ \vdash ... $' не означает, что контекст пуст, а подразумевает `$\Gamma \vdash ... $', просто не нужно прописывать `$\Gamma$' во всех правилах.

`def' оначает `определено' и все суждения вида `$\Gamma \vdash T$', где нет отношения типизации справа от `$\vdash$', в нашем языке записываются как `$ \vdash T def$'.

`$\equiv$' записывается как обычное равенство. Типизация и подстановки записываются так же, как обычно. Ограничение на то, что связывание должно быть прописано явно, даёт нам возможность проверить корректность написания подстановок.

Осталось описать редукции языка, это сделано во вставке~\ref{lst_bool_reds}. Единственный незнакомый нам символ здесь это `\lstinline{=>}', который означает `редуцируется к'. Так как редукции всегда направленные, символ `\lstinline{=>}' отражает направление редуцирования.

\begin{lstlisting}[label={lst_bool_reds}, caption={Редукции языка Bool, описанные в языке спецификации},captionpos=b, frame=single, float]
Reductions:
  Tr-If =
    forall x.T : ty, t : tm, a : tm, b : tm
      x : bool |- T def,
      |- a : T[x:=true], |- b : T[x:=false]
      |---------------------------------------
      |- if(true, x.T, a, b) => a : T[x:=true]
  Fls-If =
    forall x.T : ty, t : tm, a : tm, b : tm
      x : bool |- T def,
      |- a : T[x:=true], |- b : T[x:=false]
      |---------------------------------------
      |- if(false, x.T, a, b) => a : T[x:=false]
\end{lstlisting}

Также в языке есть возможность помечать правила вывода стабильными относительно конечного числа типов, тогда правило вывода применимо, только если все переменные входящие в терм имеют эти типы. Если список типов пуст, то производится проверка терма на отсутствие свободных переменных в терме. Эта возможность языка продемонстрирована на вставке~\ref{lst_bool_bool}. Таким образом при проверке корректности конструкции, первым делом нужно проверять, что все свободные переменные внутри терма языка имеют типы из списка.

\begin{lstlisting}[label={lst_bool_bool}, caption={Bool-стабильность правила вывода `If', описанная в языке спецификации},captionpos=b, frame=single, float]
Axioms:
  ...
  [bool]
  T-If =
    ...
\end{lstlisting}
