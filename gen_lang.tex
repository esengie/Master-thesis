\section{Реализация}
В данной секции описана реализация языка спецификации языков с зависимыми типами.

\subsection{Парсер генераторы}
В ходе всей работы использовались лексер и парсер генераторы alex\cite{alex} и happy\cite{happy}.

Решение использовать именно парсер генераторы, а не парсер комбинаторы\cite{parsec} или другие методы парсинга было обуcловлено тем, что прогнозировались частые изменения грамматики вместе с эволюцией языка.

\begin{lstlisting}[caption={Часть спецификации парсера},captionpos=b]
Axiom   :   Header '=' '\t' Forall '\t'
            Premise '|---' JudgementNoEq '/t' '/t'
              { Axiom (snd $1) (fst $1) $4 $6 $8 }
        |   Header '=' '\t'
            Premise '|---' JudgementNoEq '/t'
              { Axiom (snd $1) (fst $1) [] $4 $6 }
\end{lstlisting}

Все изменения связанные с грамматикой языка проводились на уровне спецификации AST.

\input{impl/toposort}
\input{impl/de_brujin}
\input{impl/build_exp}
\input{impl/infer_nf}

\subsection{Генерация кода}
Генерация кода происходит с использованием библиотеки haskell-src-exts\cite{src_exts}, которая дает нам функции генерации и манипуляции АСТ Haskell.

Тк большинство кода используемого для проверки не зависит от специфицированного языка, мы просто модифицируем написанный от руки модуль LangTemplate. В нем нужно определить функции приведения в нормальную форму и вывода типов. Также нужно определить тип данных термов и определить монадическое действие на типе данных термов.

Всё остальное либо генерируется с помощью Template Haskell\cite{TH} --- instance Traversable, Functor, Eq, Show, Foldable\footnote{Foldable дает нам функцию toList, которая возвращает свободные переменные терма, Traversable позволяет применять функции swap, rem и add  к переменным обходя весь терм.}, либо написано от руки с вызовами функций nf или infer.

\begin{lstlisting}[caption={Проверка типов и контексты},captionpos=b]
emptyCtx :: (Show a, Eq a) => Ctx a
emptyCtx x = Left $ "Variable not in scope: " ++ show x

consCtx :: (Show a, Eq a) => Type a -> Ctx a -> Ctx (Var a)
consCtx ty ctx B = pure (F <$> ty)
consCtx ty ctx (F a)  = (F <$>) <$> ctx a

checkT :: (Show a, Eq a) => Ctx a -> Type a -> Term a -> TC ()
checkT ctx want t = do
  have <- infer ctx t
  when (nf have /= nf want) $ Left $
    "type mismatch, have: " ++ (show have) ++ " want: " ++ (show want)
\end{lstlisting}







%--
