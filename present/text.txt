################################################################################
1.
Здр, шг, мой рук валис. Моя дипломная работа это генерация зависимых языков по спецификации пользователя
################################################################################
2.
В языках с зависимыми типами типы могут зависеть от термов языка.
Я приведу пример, чтобы это немного пояснить.
Во многих языках программирования возникают ошибки связанные с доступом за границу массива.
Аналогом этого в Хаскель является взятие первого элемента в списке.

На примере видим что все работает верно, пока есть первый элемент.
если же на вход поданы некорректные данные --
то в таких ситуациях принято использовать механизм исключений языка

Эту проблему можно решить иначе, наложив на вход дополнительные ограничения.
А именно -- не принимать такие входные данные. Экспрессивность системы типов позволяет нам это сделать

Из других примеров ограничений: функция может также принимать только упорядоченные списки.
                                массивы простых чисел, длины простого числа.

################################################################################
3.
Если мы хотим реализовать свой язык с зависимыми, перед нами встает ряд задач,
одной их основных является написание функции проверки типов

Однако  для проверки типов мы должны уметь вычислять термы языка.
Рассмотрим пример иллюстрирующий это, если мы хотим вызвать функцию, прин. списки длины числа фиб,
на конкатенции двух списков длины 2 и 3.
То для проверки типов нам нужно проверить находится ли 2+3 в списке чисел фибоначчи --
для этого нужно вычислить это выражение и сравнить его на равенство с True


То есть мы должны реализовывать синт дерево, равенство выр, их вычисление, подстановки и тд

Однако общий алгоритм проверки для всех языков с зависимыми типами схож и можно
попытаться генерировать функции проверки и нормализации по спецификации языка.

################################################################################
4. Что и явл целью нашей данной работы.

Для этого небходимо определить язык спецификации языков с зависимыми типами
и написать генерацию соотв функций

% Эта работа выполнена в контексте большей, направленной на генерацию языков программирования целиком.
% По сути нужна только возможность определения функций и парсера из именованного к неименованному представлению.

################################################################################
5. Первым шагом к генер языка, является определение языка спецификации
и множества языков, по спецификации которых можно реализовать проверку их типов

Любой язык состоит из конструкций (например язык булевых выражений состоит из 4),
правил вывода и правил редукции
################################################################################
6. Формализуем язык булевых выражений. На языке привычных правил вывода.

Все что выше черты называются предпосылками, все что ниже заключение.
Все переменные обозначающие выражения языка который мы определяем
 -- называются метапеременными. То есть здесь это T, t, a, b.

Наша задача придумать язык спецификации,
в котором бы явно описывались все ограничения этих правил.

Мы будем считать, что первые четыре правила верны во всех специфицируемых языках
и их не нужно явно записывать.

Осталось явно описать только четыре последних правила.
Можно увидеть что эти правила вводят 4 наши конструкции из пред слайда.
################################################################################
7.
Давайте подробнее рассмотрим правило вывода для конструкции if.

Видно что в языке два уровня выражений -- типы и термы.
Также неявно подразумевается, что if принимает терм, тип и два терма.

Интерес представляет первая предпосылка -- а именно тип T.
У него в данной нотации неявно подразумевается более широкий контекст,
чем у всех остальных метапеременных --
зададим ограничение, что в языке спецификации это нужно указывать явно.
###############################################################################
8. Перенесем наши замечания на язык спецификации,
Наша спец должна начин с описания всех видов выражений
и всех конструкций, которые должны быть явно аннотированы видами аргументов
и темнасколько у них больше переменных в сравнении с общим контекстом

################################################################################
9. Опишем как выглядят правила вывода в нашей спецификации на примере
правила вывода конст if.

Все метапеременные явно аннотированы видами и контекстами в которых они определены
Синтаксис предпосылок и заключения такой же как и у обычного способа записи
###############################################################################
10. Мы описали наш язык как проходит проверка типов? Рассотрим на примере


################################################################################
11. Язык накладывает следующие ограниения на спецификации,
отчасти уже мотивированные пред примером

-- 1 пр -- если их несколько могут возн сложности, какие??
-- все мета перед
  это связано с тем, что иначе их неоткуда будет взять для построения предпослык
-- чтобы можно было вернуть тип
-- если разрешить ненапр равенства, то не особо ясно что с ними делать
-- стил ограничение
################################################################################
12. Из того же примера вывода типов можно заключить что от представления треб
....
Это все дает нам библиотека bound.
bound исп обобщенные индексы де Брейна, чтобы модифицировать поддеревья выр за O(1)
но это не дает нам соп с образцом, использование обычных индексов, позв удовл всем трем условиям

################################################################################
13. Итак, после того как пользователь задает спек. Проходит проверка корректности,
генерация представления с помошью упрощенной библиотеки bound.
Генерируется код функции проверки типов, работающей так как было описано на примере
конструкции ифф и нормализации,
которая по очереди пытается применить редукции к выражению.
################################################################################
14. В итоге был реализован язк спецификации языков прогр с зависимыми типами
и реализована генерация функции проверки типов и вычисления термов.
Код программы находится на след репо.


На каждую задачу - 1-2 слайда

по сути генерируется библиотечка для работы с языком.
