################################################################################
1.
Здр, ШГ, мой рук. Валерий Исаев. Моя дипломная работа это генерация зависимых языков по спецификации пользователя
################################################################################
2.
Начнем с краткого введения в зависимые типы
В языках с зависимыми типами типы могут зависеть от термов языка.
Я приведу пример, чтобы это немного пояснить.
Во многих языках программирования возникают ошибки связанные с доступом за границу массива.
Аналогом этой ошибки в языке Хаскель является взятие первого элемента в пустом списке.
В таких ситуациях принято использовать механизм исключений языка или его аналоги

Эту проблему можно решить иначе, наложив на вход дополнительные ограничения.
А именно -- не принимать пустые списки. Экспрессивность системы типов позволяет нам это сделать

Вообще можно вводить произвольные ограничения:
  функция может также принимать только упорядоченные списки.
  массивы простых чисел, длины простого числа.

################################################################################
3.
Если мы хотим реализовать свой язык с зависимыми типами, перед нами встает ряд задач,
одной из основных задач является написание функции проверки типов

Однако  для проверки типов мы должны уметь вычислять термы языка.
Рассмотрим пример иллюстрирующий это, если мы хотим вызвать функцию, прин. списки длины числа фиб,
на конкатенции двух списков длины 2 и 3.
Для проверки корректности входного списка нам нужно проверить находится ли 2+3 в списке чисел фибоначчи --
Функции проверки вхождения, генерации чисел фибоначчи и сложения чисел определены в самом языке
и для проверки этого условия нужно их вычислять.

Однако общий алгоритм проверки для всех языков с зависимыми типами схож и можно
попытаться генерировать функции проверки и вычисления по спецификации языка.

################################################################################
4. Что и явл целью нашей данной работы.

Для этого небходимо определить язык спецификации языков с зависимыми типами
и написать генерацию соотв функций

Также можно генерировать синтаксический анализатор, чтобы пользователь мог работать не внутри Haskell,
а писал программы в отдельных текстовых файлах языка.

################################################################################
5. Первым шагом для создание инструмента генер языка, является определение языка спецификации
и ограничение множества спецификаций для которых можно реализовать проверку их типов

Любой язык состоит из конструкций (например язык булевых выражений состоит из 4),
правил вывода и правил редукции
################################################################################
6. Формализуем язык булевых выражений на языке привычных правил вывода.

Как видим здесь предст несколько пр. выв. (еще нужны два правила редукции)

Наша задача придумать язык спецификации,
в котором бы явно описывались все ограничения этих правил.

Мы будем считать, что первые четыре правила верны во всех специфицируемых языках
и их не нужно явно записывать.

Осталось явно описать только четыре последних правила.
Можно увидеть что эти правила вводят 4 наши конструкции из пред слайда.
################################################################################
7.
рассмотрим подробнее правило вывода для конструкции if.

Видно что в языке два уровня выражений -- типы и термы.
Также неявно подразумевается, что if принимает терм, тип и два терма.

Все что выше черты называются предпосылками, все что ниже заключением.

Интерес  представляет первая предпосылка -- а именно тип T.
У него в данной нотации неявно подразумевается более широкий контекст,
чем у всех остальных метапеременных.
Все эти ограничения  в языке спецификации нужно указывать явно.
###############################################################################
8. Перепишем язык Bool на языке спецификации,
Наша спец должна начин с описания всех видов выражений
и всех конструкций, которые должны быть явно аннотированы видами аргументов
и тем, насколько у них больше переменных в сравнении с общим контекстом
################################################################################
9. Сами правила вывода выглядят следующим образом (на примере конструкциии if)

Все метапеременные явно аннотированы видами и контекстами в которых они определены
Синтаксис предпосылок и заключения такой же как и у обычного способа записи.
Гамма подразумевается в контекстах всех суждений
###############################################################################
10. Мы описали наш язык, рассмотрим как проходит вывод типов
на примере того же правила If

...

################################################################################
11. Давайте теперь вернемся к ограничениям которые накладывает язык специфкации:

-- все мета перед  это связано с тем, что иначе их неоткуда будет взять для построения предпослык
-- если разрешить ненапр равенства, то не особо ясно что с ними делать
-- как и в 1
-- 1 пр -- нужно подробнее изучить случай с несколькими
-- стил ограничение
################################################################################
12. Из того же примера вывода типов можно заключить что от представления выражений языка требуется
....
Это все дает нам библиотека bound.
bound исп обобщенные индексы де Брейна, чтобы модифицировать поддеревья выражений за O(1)
но это не дает нам сопост. с образцом, использование же обычных индексов, позволяет удовлетворить всем трем условиям

################################################################################
13. Итак, после того как пользователь задает спек. Проходит проверка корректности,
генерация представления с помошью упрощенной библиотеки bound.
Генерируется код функции нормализации и проверки типов, работающей так как было описано на примере раньше,
которая по очереди пытается применить редукции к выражению.
################################################################################
14. В итоге был определен язык спецификации языков прогр с зависимыми типами
и реализованы генерация представления выражений, функции проверки типов и функции вычисления термов.

Код программы находится на след репо.

----------------------------------------------------
На каждую задачу - 1-2 слайда

по сути генерируется библиотечка для работы с языком.
