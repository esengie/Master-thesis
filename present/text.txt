################################################################################
1.
Здр, шг, мой рук валис. Моя дипломная работа это генерация зависимых языков по спецификации пользователя
################################################################################
2.
Начну с краткого введения в зависимые типы
В языках с зависимыми типами типы могут зависеть от термов языка.
Я приведу пример, чтобы это немного пояснить.
Во многих языках программирования возникают ошибки связанные с доступом за границу массива.
Аналогом этой ошибки в языке Хаскель является взятие первого элемента в пустом списке.
В таких ситуациях принято использовать механизм исключений языка или его аналоги

Эту проблему можно решить иначе, наложив на вход дополнительные ограничения.
А именно -- не принимать пустые списки. Экспрессивность системы типов позволяет нам это сделать

Вообще можно вводить произвольные ограничения:
  функция может также принимать только упорядоченные списки.
  массивы простых чисел, длины простого числа.

################################################################################
3.
Если мы хотим реализовать свой язык с зависимыми типами, перед нами встает ряд задач,
одной из основных задач является написание функции проверки типов

Однако  для проверки типов мы должны уметь вычислять термы языка.
Рассмотрим пример иллюстрирующий это, если мы хотим вызвать функцию, прин. списки длины числа фиб,
на конкатенции двух списков длины 2 и 3.
Для проверки корректности входного списка нам нужно проверить находится ли 2+3 в списке чисел фибоначчи --
Функции проверки вхождения, генерации чисел фибоначчи и сложения чисел определены в самом языке
и для проверки этого условия нужно их вычислять.

Также мы должны реализовывать привычные предст синт дерева, равенство выр, их вычисление, подстановки и тд

Однако общий алгоритм проверки для всех языков с зависимыми типами схож и можно
попытаться генерировать функции проверки и нормализации по спецификации языка.

################################################################################
4. Что и явл целью нашей данной работы.

Для этого небходимо определить язык спецификации языков с зависимыми типами
и написать генерацию соотв функций

% Эта работа выполнена в контексте большей, направленной на генерацию языков программирования целиком.
% По сути нужна только возможность определения функций и парсера из именованного к неименованному представлению.

################################################################################
5. Первым шагом для создание инструмента генер языка, является определение языка спецификации
и множества языков, по спецификации которых можно реализовать проверку их типов

Любой язык состоит из конструкций (например язык булевых выражений состоит из 4),
правил вывода и правил редукции
################################################################################
6. Формализуем язык булевых выражений. На языке привычных правил вывода.

Наша задача придумать язык спецификации,
в котором бы явно описывались все ограничения этих правил.

Мы будем считать, что первые четыре правила верны во всех специфицируемых языках
и их не нужно явно записывать.

Все что выше черты называются предпосылками, все что ниже заключение.

Осталось явно описать только четыре последних правила.
Можно увидеть что эти правила вводят 4 наши конструкции из пред слайда.
################################################################################
7.
рассмотрим подробнее правило вывода для конструкции if.

Видно что в языке два уровня выражений -- типы и термы.
Также неявно подразумевается, что if принимает терм, тип и два терма.

Интерес представляет первая предпосылка -- а именно тип T.
У него в данной нотации неявно подразумевается более широкий контекст,
чем у всех остальных метапеременных --
зададим ограничение, что в языке спецификации это нужно указывать явно.
###############################################################################
8. Перенесем наши замечания на язык спецификации,
Наша спец должна начин с описания всех видов выражений
и всех конструкций, которые должны быть явно аннотированы видами аргументов
и темнасколько у них больше переменных в сравнении с общим контекстом

################################################################################
9. Покажем на примере правила вывода конст if
как правила вывода выглядят в нашей спецификации

Все метапеременные явно аннотированы видами и контекстами в которых они определены
Синтаксис предпосылок и заключения такой же как и у обычного способа записи
Гамма подразумевается в контекстах всех
###############################################################################
10. Мы описали наш язык, рассмотрим как проходит вывод типов
на примере того же правила If


################################################################################
11. Мы рассмотрели вывода типов, вернемся к ограничениям которые накладывает язык специфкации:

-- 1 пр -- если их несколько могут возн сложности, какие??
-- все мета перед
  это связано с тем, что иначе их неоткуда будет взять для построения предпослык, нет скрытых параметров
-- чтобы можно было вернуть тип
-- если разрешить ненапр равенства, то не особо ясно что с ними делать
-- стил ограничение
################################################################################
12. Из того же примера вывода типов можно заключить что от представления выражений треб
....
Это все дает нам библиотека bound.
bound исп обобщенные индексы де Брейна, чтобы модифицировать поддеревья выр за O(1)
но это не дает нам соп с образцом, использование обычных индексов, позв удовл всем трем условиям

################################################################################
13. Итак, после того как пользователь задает спек. Проходит проверка корректности,
генерация представления с помошью упрощенной библиотеки bound.
Генерируется код функции проверки типов, работающей так как было описано на примере
конструкции ифф и нормализации,
которая по очереди пытается применить редукции к выражению.
################################################################################
14. В итоге был реализован язк спецификации языков прогр с зависимыми типами
и реализована генерация функции проверки типов и вычисления термов.

Код программы находится на след репо.

----------------------------------------------------
На каждую задачу - 1-2 слайда

по сути генерируется библиотечка для работы с языком.
