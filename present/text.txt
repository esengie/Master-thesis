################################################################################
1.
Здр, шг, мой рук валис. Моя дипломная работа это генерация зависимых языков по спецификации пользователя
################################################################################
2.
Начнем с введения в область. Если кратко, в языках с зависимыми типами типы могут зависеть от термов.
Я приведу пример, чтобы это немного пояснить.
Во многих языках программирования возникают ошибки связанные с доступом за границу массива.
Аналогом этого в Хаскель является взятие первого элемента в списке.

На примере видим что все хорошо, пока есть первый элемент.

В таких ситуациях принято кидать исключения если на вход поданы некорректные данные.
Эту проблему можно решить иначе, наложив на вход дополнительные ограничения.
А именно -- не принимать такие входные данные.

Из других примеров ограничений: функция может также принмать только
Упорядоченные списки.
массивы простых чисел, длины простого числа.

################################################################################
3.
Если мы хотим реализовать свой язык, перед нами встает ряд задач, которые мы может быть не хотим решать.

Однако проверка типов в зависимых языках не совсем тривиальная задача,
так как для проверки типов мы должны уметь вычислять термы.
Например если мы принимаем списки длины числа фиб, а получили конкатенцию списков длины 2 и 3

Чтобы проверить  Понятно что это равенство зависит от определений функций fib и '+'.

Однако общий алгоритм проверки для всех языков с зависимыми типами схож и можно
просто генерировать функции проверки и нормализации по спецификации языка.
Во время проверки типов мы всегда рекурсивно спукаемся и проверяем соотв правила.

################################################################################

################################################################################
4.
% Эта работа выполнена в контексте большей, направленной на генерацию языков программирования целиком.
% По сути нужна только возможность определения функций и парсера из именованного к неименованному представлению.

цели описать
################################################################################

################################################################################
5. Чего мы хотим от любого языка --- конструкции, как эти конструкции можно использовать
и как они вычисляются.
################################################################################
6. Пример с булями
################################################################################

################################################################################
7.
Одной из первых проблем которую нужно решать при такого рода реализации языка это представление АСД языка.
При наивном подходе к представлению АСД, когда переменные это просто строки возникает проблема проверки
термов на альфа-эквивалентность и проблема захвата свободных переменных.

Реализация проверки типов будет зависеть от представления.

Поэтому было решено использовать индексы де брейна с полиморфной рекурсией,
тк абстракцию можно написать локально, не описывая работы со связываниями.
################################################################################

################################################################################
8. 

################################################################################

################################################################################

################################################################################



На каждую задачу - 1-2 слайда

по сути генерируется библиотечка для работы с языком.
