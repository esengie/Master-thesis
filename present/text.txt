################################################################################
1.
Здр, шг, мой рук валис. Моя дипломная работа это генерация зависимых языков по спецификации пользователя
################################################################################
2.
Начнем с введения в область. Если кратко, в языках с зависимыми типами типы могут зависеть от термов языка.
Я приведу пример, чтобы это немного пояснить.
Во многих языках программирования возникают ошибки связанные с доступом за границу массива.
Аналогом этого в Хаскель является взятие первого элемента в списке.

На примере видим что все работает верно, пока есть первый элемент.
если на вход поданы некорректные данные --
то в таких ситуациях принято использовать механизм исключений языка

Эту проблему можно решить иначе, наложив на вход дополнительные ограничения.
А именно -- не принимать такие входные данные. Экспрессивность системы типов позволяет нам это сделать

Из других примеров ограничений: функция может также принимать только упорядоченные списки.
                                массивы простых чисел, длины простого числа.

################################################################################
3.
Если мы хотим реализовать свой язык, перед нами встает ряд задач, которые мы может быть не хотим решать.

Однако проверка типов в зависимых языках не совсем тривиальная задача,
так как для проверки типов мы должны уметь вычислять термы.
Например если мы принимаем списки длины числа фиб, а получили конкатенцию списков длины 2 и 3

Чтобы проверить  Понятно что это равенство зависит от определений функций fib и '+'.

Однако общий алгоритм проверки для всех языков с зависимыми типами схож и можно
просто генерировать функции проверки и нормализации по спецификации языка.
Во время проверки типов мы всегда рекурсивно спукаемся и проверяем соотв правила.

################################################################################

################################################################################
4.
% Эта работа выполнена в контексте большей, направленной на генерацию языков программирования целиком.
% По сути нужна только возможность определения функций и парсера из именованного к неименованному представлению.

цели описать
################################################################################

################################################################################
5. Раз мы хотим генерировать язык по спецификации, давайте определим эту спецификацию.
Любой язык состоит из конструкций языка, правил
################################################################################
6. Сперва формализуем язык с булевыми выражениями. На языке привычных правил вывода.

Все что выше черты называются предпосылки, все что ниже заключение.
Все переменные обозначающие выражения языка который мы определяем
 -- называются метапеременными. То есть здесь это T, t, a, b.

Наша задача придумать язык спецификации,
в котором бы явно описывались все предположения этих правил.

Мы будем считать, что первые четыре правила верны во всех специфицируемых языках и их явно писать не надо.

Осталось явно описать только четыре последних правила.
Можем увидеть что все правила вводят 4 наши конструкции из пред слайда.
################################################################################
7.
Давайте подробнее рассмотрим правило вывода для if.

Видим что здесь два уровня выражений -- типы и термы.
Также неявно подразумевается, что if принимает терм, тип и два терма.

Также интерес представляет четвертое правило -- а именно тип T.
У него в данной нотации неявно на один шире контекст, чем у всех остальных переменных
-- в языке спецификации это нужно указывать явно.


################################################################################

################################################################################
7.
Одной из первых проблем которую нужно решать при такого рода реализации языка это представление АСД языка.
При наивном подходе к представлению АСД, когда переменные это просто строки возникает проблема проверки
термов на альфа-эквивалентность и проблема захвата свободных переменных.

Реализация проверки типов будет зависеть от представления.

Поэтому было решено использовать индексы де брейна с полиморфной рекурсией,
тк абстракцию можно написать локально, не описывая работы со связываниями.
################################################################################

################################################################################
8. Есть проверка на равенство, абстракция по переменной, подстановка в самую верхнюю.

В принципе нужно только уметь переставлять индексы

Остается написать только функции вывода типа и нормализации

################################################################################

################################################################################

################################################################################



На каждую задачу - 1-2 слайда

по сути генерируется библиотечка для работы с языком.
