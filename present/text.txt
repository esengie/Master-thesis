################################################################################
1.
Здр, шг, мой рук валис. Моя дипломная работа это генерация зависимых языков по спецификации пользователя
################################################################################
2.
Начнем с введения в область. Если кратко, в языках с зависимыми типами типы могут зависеть от термов.
Я приведу пример, чтобы это немного пояснить.
Во многих языках программирования возникают ошибки связанные с доступом за границу массива.
Аналогом этого в Хаскель является взятие первого элемента в списке.

На примере видим что все хорошо, пока есть первый элемент.

В таких ситуациях принято кидать исключения если на вход поданы некорректные данные.
Эту проблему можно решить иначе, наложив на вход дополнительные ограничения.
А именно -- не принимать такие входные данные.

Из других примеров ограничений: функция может также принмать только
Упорядоченные списки.
массивы простых чисел, длины простого числа.

################################################################################
3.
Зависимые языки достаточно экспрессивный инструмент,
и обычно их используют для формализации математики и написания доказательств.

Но могут возникнуть ситуации, когда конструкций языка недостаточно, для описания нашей теории.
Тогда одно из решений это описывание и реализация своего языка.
Или если как разработчик языка мы просто хотим поэкспериментировать с определением языка,
но не хотим писать и проверять написанный код на корректность

Однако проверка типов в зависимых языках не совсем тривиальная задача,
так как для проверки типов мы должны уметь вычислять термы.
Например если мы принимаем списки длины слева, а получили что-то вида справа.

Понятно что это равенство зависит от определений функций fib и '+'.

Однако общий алгоритм проверки для всех языков с зависимыми типами схож и можно
просто генерировать функции проверки и нормализации по спецификации языка.
################################################################################
Именно этой задачей и занимается наша утилита.
################################################################################
4.
% Эта работа выполнена в контексте большей, направленной на генерацию языков программирования целиком.
% По сути нужна только возможность определения функций и парсера из именованного к неименованному представлению.
цели описать
################################################################################

################################################################################
5. Чего мы хотим от любого языка --- конструкции, как эти конструкции можно использовать
и как они вычисляются.
################################################################################

################################################################################
7.
Одной из первых проблем которую нужно решать при такого рода реализации языка это представление АСТ языка.
При наивном подходе к представлению АСТ, когда переменные это просто строки возникает проблема проверки
термов на альфа-эквивалентность и проблема захвата свободных переменных.

Поэтому было решено использовать индексы де брейна
################################################################################


################################################################################


################################################################################

################################################################################

################################################################################



На каждую задачу - 1-2 слайда

по сути генерируется библиотечка для работы с языком.
