%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Введение}

Языки с зависимыми типами --- типы могут зависеть от термов.

Одна из частых ошибок при программировнии на языке Haskell --- взятие первого элемента пустого списка.

\begin{verbatim}
head :: [a] -> a
head (x:_) = x
head [] = error "No head!"
\end{verbatim}

В языке с зависимыми типами мы можем усилить ограничения на входные данные функции.

\begin{verbatim}
head :: {n : N} -> Vec a (suc n) -> a
head (x:_) = x
\end{verbatim}

\end{frame}

%------------------------------------------------
\begin{frame}
\frametitle{Применение языков с зависимыми типами}

\begin{itemize}
\item Одно из основных применений языков с зависимыми это доказательство утверждений
\item Конструкции нужные нам могут отстутствовать в языке
\item Решение --- реализовать свой язык с нужными конструкциями
\item Для проверки равенств в типах нужно уметь нормализовывать выражения языка.
\textit{Нормализация} --- применение редукций для переписывания выражения, пока это возможно
\item $(\lambda x \rightarrow fib(x)) 3 == 1 + 5$?
\item Алгоритм всегда один и тот же --- есть возможность кодогенерации
\end{itemize}
\end{frame}
%------------------------------------------------

\begin{frame}
\frametitle{Цели и задачи}
Реализовать генерацию алгоритма проверки типов и вычислителя зависимых языков по спецификации

\begin{itemize}
\item Разработка языка спецификации и налагемых им ограничений
\item Выбор внутреннего представления АСД и генерация структур данных конструкций языка
\item Генерация кода функций проверки типов и нормализации
\end{itemize}
\end{frame}
%------------------------------------------------

\begin{frame}
\frametitle{Спецификация языка}
Язык программирования состоят из
\begin{itemize}
\item Конструкций
\item Правил построения конструкций (правил вывода)
\item Правил вычисления (редукций)
\end{itemize}
\end{frame}
%------------------------------------------------
\begin{frame}[fragile]
\begin{columns}[T] % align columns
\begin{column}{.48\textwidth}

\begin{center}
\AxiomC{}
\UnaryInfC{$\vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash A$}
\RightLabel{, $x \notin \Gamma$}
\UnaryInfC{$\Gamma, x : A \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash$}
\RightLabel{, $x : A \in \Gamma$}
\UnaryInfC{$\Gamma \vdash x : A$}
\DisplayProof
\end{center}

\medskip
\begin{center}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash B$}
\RightLabel{, $A \equiv B$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\end{center}

\end{column}%

\hfill%

\begin{column}{.48\textwidth}

\begin{verbatim}
Наше представление
\end{verbatim}

\end{column}%
\end{columns}

\end{frame}
%------------------------------------------------
\begin{frame}
\frametitle{Ограничения накладываемые языком?}
\begin{itemize}
\item Топосорт
\item Проверка типов и проч
\item Идея в том, что этим мы отличаемся от всяких LF
\end{itemize}
\end{frame}
%------------------------------------------------
\begin{frame}
\frametitle{Внутреннее представление}
Индексы де Брейна?
\end{frame}
%------------------------------------------------
\begin{frame}
\frametitle{Генерация кода}
Индексы де Брейна?
\end{frame}
%------------------------------------------------
\begin{frame}[fragile]
\frametitle{Пример кода?}

\end{frame}

\begin{frame}
\frametitle{Результаты}
Реализована генерация алгоритма проверки типов и вычислителя зависимых языков по спецификации.

\begin{itemize}
\item Спроектирован типизированный язык спецификации
\item Генерация структур данных конструкций языка с использованием индексов де Брейна на уровне типов с использованием полиморфной рекурсии
\item Генерация кода функции проверки типов термов специфицированного языка с передачей контекстов свободных переменных и функции нормализации на основе сопоставления с образцом
\end{itemize}

Репозиторий проекта: \url{github.com/esengie/fpl-exploration-tool/}
\end{frame}
