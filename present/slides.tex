%----------------------------------------------------------------------------------------
%	PRESENTATION SLIDES
%----------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Введение}

Языки с зависимыми типами --- типы могут зависеть от термов.

Одна из частых ошибок при программировнии на языке Haskell --- взятие первого элемента пустого списка.

\begin{verbatim}
head :: [a] -> a
head (x:_) = x
head [] = error "No head!"
\end{verbatim}

В языке с зависимыми типами мы можем усилить ограничения на входные данные функции.

\begin{verbatim}
head :: {n : N} -> Vec a (suc n) -> a
head (x:_) = x
\end{verbatim}

\end{frame}

%------------------------------------------------
\begin{frame}
\frametitle{Реализация языков с зависимыми типами}

\begin{itemize}
\item При написании функции проверки типов нужно уметь вычислять выражения языка.
  \begin{itemize}
    \item Можно ли применить функцию \lstinline{takes_only_fib_list} к \lstinline{[1, 3] ++ [1, 2, 3]}?
    \item $elem\ (2 + 3)\ fibonacci == True$? Зависит от определений $elem$, $fibonacci$ и $+$
    \item $fibonacci =$ \lstinline{[1, 1, 2, 3, 5, 8, ...]}
  \end{itemize}
% \item Требуются следующие операции над выражениями: проверка на равенство, подстановка в переменную и абстракция
\item Схема алгоритма проверки всегда одна и та же --- есть возможность кодогенерации

\end{itemize}

\end{frame}
%------------------------------------------------

\begin{frame}
\frametitle{Цели и задачи}
\textbf{Цель:} Реализовать алгоритм генерации функции вычисления и проверки типов зависимых языков по спецификации в виде модуля на Haskell

\hfill

\textbf{Задачи:}
\begin{itemize}
\item Разработка языка спецификации и налагемых им ограничений
% \item Выбор внутреннего представления АСД и генерация структур данных конструкций языка
\item Генерация кода функций проверки типов и вычисления термов
\end{itemize}
\end{frame}
%------------------------------------------------

\begin{frame}
\frametitle{Язык спецификаций}
Необходимо определить язык спецификации и ограничить выразимые языки для возможности дальнейшей генерации кода

\hfill

Функциональные языки программирования состоят из:
\begin{itemize}
\item Конструкций (true, false, bool, if)
\item Правил типизации конструкций (правил вывода)
\item Правил вычисления (редукций)
\end{itemize}
\end{frame}
%------------------------------------------------
\begin{frame}
\frametitle{Формальное определение языка Bool}
\begin{center}
\AxiomC{}
\UnaryInfC{$\vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash A$}
\RightLabel{, $x \notin \Gamma$}
\UnaryInfC{$\Gamma, x : A \vdash$}
\DisplayProof
\quad
\AxiomC{$\Gamma \vdash$}
\RightLabel{, $x : A \in \Gamma$}
\UnaryInfC{$\Gamma \vdash x : A$}
\DisplayProof
\end{center}

\medskip

\begin{center}
\AxiomC{$\Gamma \vdash a : A$}
\AxiomC{$\Gamma \vdash A \equiv B$}
\BinaryInfC{$\Gamma \vdash a : B$}
\DisplayProof
\end{center}

\begin{center}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash Bool$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\Gamma \vdash True : Bool$}
\DisplayProof
\quad
\AxiomC{}
\UnaryInfC{$\Gamma \vdash False : Bool$}
\DisplayProof
\end{center}

\medskip

\IFF

\end{frame}

% ------------------------------------------------------

\begin{frame}
\frametitle{Неявные предположения формального определения}

\IFF

\begin{itemize}
\item Все выражения делятся на два вида: термы и типы
\item Конструкция if принимает аргументы вида (терм, тип, терм, терм)
\item Контекст типа $T$ шире, чем стандартный контекст $\Gamma$
\end{itemize}

\end{frame}

% ------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Типизация спецификации языка Bool}
\begin{verbatim}
DependentSorts:
  tm, ty
Constructs:
  if: (tm,0)*(ty,1)*(tm,0)*(tm,0) -> tm
  bool: ty
  true : tm
  false : tm
\end{verbatim}
\end{frame}

% ------------------------------------------------

\begin{frame}[fragile]
\frametitle{Спецификация правила вывода конструкции if}

\IFF

Все переменные обозначающие выражения языка который мы определяем --- называются \textit{метапеременными}

\begin{verbatim}
forall x.T : ty, t : tm, a : tm, b : tm
  |- t : bool, x : bool |- T def,
  |- a : T[x:=true], |- b : T[x:=false]
  |---------------------------------------
  |- if(t, x.T, a, b) : T[x:=t]
\end{verbatim}

\end{frame}
%------------------------------------------------
\begin{frame}
\frametitle{Вывод типов на примере конструкции if}

\IFF

\begin{enumerate}
\item На вход подается контекст и $if(t, T, a, b)$
\item Расширяем контекст типом $bool$ и проверяем определенность типа $T$
\item Проверяем, что тип $t$ совпадает с типом $bool$
\item Выводим тип $a$ и проверяем, что его н.ф. совпадает с н.ф. $T[x:=true]$
\item Выводим тип $b$ и проверяем, что его н.ф. совпадает с н.ф. $T[x:=false]$
% везде проверяем что типы это типы!!
\item Возвращаем тип выражения $T[x:=t]$
\end{enumerate}
Выражение в \textit{нормальной форме} --- выражение, к которому нельзя применить редукций
\end{frame}

%------------------------------------------------
\begin{frame}
\frametitle{Ограничения накладываемые языком спецификации}
\begin{itemize}
\item Все метапеременные передаются в виде аргументов конструкции
\item Конструкция в заключении, возвращающая терм, должна быть проаннотирована типом
\item Запрещены равенства в заключении, для этого используются редукции
\item Одно правило введения на каждую конструкцию языка
\item Запрещено перекрытие переменных в контексте
\end{itemize}
\end{frame}
%------------------------------------------------
\begin{frame}
\frametitle{Реализация: представление АСД языка}
\begin{itemize}
\item От представления языка требуются возможности:
  \begin{itemize}
    \item Проверки выражений на равенство
    \item Подстановки в переменные и абстракции
    \item Сопоставление с образцом для нормализации выражений
  \end{itemize}
\item Все эти задачи, кроме последней, решает библиотека bound
\item bound использует обобщённые индексы де Брейна
\item Можно упростить --- использовать обычные индексы
\end{itemize}
\end{frame}
%------------------------------------------------
\begin{frame}
\frametitle{Реализация: алгоритм}
\begin{enumerate}
\item Проходит проверка корректности спецификации
\item Генерируется представление выражений языка при помощи упрощённой библиотеки bound
\item Генерируются операции подстановки, абстракции и проверки на равенство выражений
\item Генерируются функции вывода типов и приведения в нормальную форму
\end{enumerate}
\end{frame}

%-----------------------------------------------------------------------------

\begin{frame}
\frametitle{Результаты}
Реализована генерация алгоритма проверки типов и вычислителя зависимых языков по спецификации.
\begin{itemize}
\item Спроектирован типизированный язык спецификации
\item Генерация структуры данных выражений языка и операций над ними
\item Генерация кода функций вывода типов термов и функции нормализации специфицированного языка
\end{itemize}

Репозиторий проекта: \url{https://github.com/esengie/fpl-exploration-tool/}
\end{frame}

%------------------------------------------------------------------------------
% \begin{frame}
% \frametitle{Дальнейшие планы?}
%
% Стоит их включать или нет?
%
% \end{frame}
