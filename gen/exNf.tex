\pagebreak
\subsubsection{Пример генерации функции нормализации}

Функция nf пытается сопоставиться с образцом на выражении, если это не выходит, то данная редукция неприменима. Поэтому нужен способ отслеживать, какие редукции уже были опробованы, а какие нет. Это делается с помощью структуры данных Cnt:

\begin{lstlisting}
data Cnt = Bot | U (Cnt)
  deriving(Eq, Show)
\end{lstlisting}

Эта структура служит в качестве целого числа, которое мы инициализируем количеством редукций применимых к нашей кострукции языка, и каждая несовпавшая редукция вызывает функцию nf c меньшим и меньшим числом, если же мы доходим до нуля (Bot), то мы истощили набор применимых редукций --- а значит выражение находится в нормальной форме.

Стоит отметить, что такое сопоставление с образцом невозможно с использованием библиотеки bound\cite{bound}, поэтому был написан модуль SimpleBound c обычными, а не обобщенными, индексами де Брейна (это было упомянуто в Разделе~\ref{de_brujin_impl}).

Рассмотрим работу алгоритма на примере редукций конструкции `If' (см. вставку~\ref{iffreds}).

\begin{lstlisting}[label={iffreds}, caption={Правила редукций для конструкции If},captionpos=b, frame=single, float, floatplacement=H]
IfRed1 =
  forall x.A : ty, f : tm , g : tm
    |--- |- if(x.A, true, f, g) => f : A[x:=true]
IfRed2 =
  forall x.A : ty, f : tm , g : tm
    |--- |- if(x.A, false, f, g) => g : A[x:=true]
\end{lstlisting}

(Дальнейший текст лучше читать имея вставку~\ref{lst_if_nf} перед глазами.)

Если у конструкции есть редукции, то функция nf вызывает функцию nf', в которую передает количество возможных редукций для данной конструкции. Также она передает нормализованные внутренние выражения для того, чтобы сопоставление с образцом было корректным (так как в работе алгоритма и при описании редукций языка подразумевается нормальная форма внутренних конструкций).

Строки 6 и 15 соответствуют сопоставлению с образцом левой части редукции. Случай, когда выражение находится в нормальной форме учтен на строке 24.

Внутри каждой функции происходит попытка построения правой части редукции таким же способом, как это происходит в функции вывода типов infer. То есть так же внутри монады `TC'. Но теперь в случае ошибки мы просто пытаемся применить следующую редукцию к выражению.

Это можно заметить на строках 13 и 22 --- в случае ошибки рекурсивно вызывается функция nf' с понижением счетчика на единицу.

В случае применимости редукции мы вызываем функцию nf на правой части редукции. Стоит отметить отличие возвращаемого значения строк 14 и 23 от возвращаемого значения в строке 24. Если нет применимых редукций, то выражение в нормальной форме. Если есть, то правая часть редукции может быть редуцирована дальше.

\begin{lstlisting}[caption={Приведение в нормальную форму пытается применить все редукции данного функционального символа},captionpos=b, frame=single, float, floatplacement=H, label={lst_if_nf}, numbers=left]
nf :: (Show a, Eq a) => Term a -> Term a
nf (If v1 v2 v3 v4)
  = nf' (U (U Bot)) (If (nf1 v1) (nf v2) (nf v3) (nf v4))

nf':: (Show a, Eq a) => Cnt -> Term a -> Term a
nf' (U (U _)) al@(If (Scope v1) True v2 v3)
  = case
      do v4 <- pure v1
         v5 <- pure v2
         v6 <- pure v3
         pure v5
      of
        Left _ -> nf' (U Bot) al
        Right x -> nf x
nf' (U _) al@(If (Scope v1) False v2 v3)
  = case
      do v4 <- pure v1
         v5 <- pure v2
         v6 <- pure v3
         pure v6
      of
        Left _ -> nf' Bot al
        Right x -> nf x
nf' _ x = x
\end{lstlisting}

Во вставке~\ref{lst_lam_nf} показан пример того, что происходит, если  у конструкции нет редукций --- нормализуются выражения внутри и возвращается модифицированное выражение.

\begin{lstlisting}[caption={Приведение в нормальную форму конструкции, у которой нет редукций}, captionpos=b, frame=single, float, floatplacement=H, label={lst_lam_nf}]
nf (Lam v1 v2) = Lam (nf v1) (nf1 v2)

nf1 x = (toScope $ nf $ fromScope x)
\end{lstlisting}
