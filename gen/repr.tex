\subsection{Структура модуля генерации кода}\label{repr}
Генерация кода происходит внутри монады GenM, которая является стэком монад: `\lstinline{ReaderT SymbolTable (StateT CodeGen (ErrorM))}'.

\begin{lstlisting}[caption={Структура используемая при кодогенерации},captionpos=b,frame=single]
data CodeGen = Gen{
, decls :: [Decl]
}
\end{lstlisting}

Так как структура заполняемая модулем проверки спецификации не меняется на этапе кодогенерации, она находится внутри монады ReaderT. При кодогенерации происходит генерация деклараций языка Haskell, которые хранятся в виде списка, затем все эти декларации будут добавлены в модуль опредения языка.

Из-за того, что функции `infer' и `nf' определяются при помощи сопоставления с образцом конструкций языка (также нужно сопоставляться с образцом с переменными), и каждое сопоставление функции с образцом считается отдельной декларацией АСД Haskell, можно считать генерацию каждой декларации в некотором смысле отдельной задачей. А именно --- все переменные введенные внутри одной декларации могут быть переиспользованы внутри другой.

Поэтому для генерации каждой отдельной декларации функций `infer' и `nf' создается внутренная монада BldRM, которая определена как `\lstinline{StateT Q (ErrorM)}'.

\begin{lstlisting}[caption={Структура используемая при кодогенерации функций `infer' и `nf'},captionpos=b,frame=single]
data Q = Q {
  _count :: Int,
  _doStmts :: [Stmt],
  _metas :: Map.Map MetaVar [(Ctx, Exp)],
  -- These three, below are used for infer only
  _juds  :: Juds,
  _foralls :: Map.Map MetaVar Sort,
  _funsyms :: Map.Map AST.Name FunctionalSymbol
}

data Juds = Juds {
  _metaTyDefs :: [(MetaVar, Judgement)],
  _notDefsTy :: [(Term, Judgement)],
  _otherJuds :: [Judgement]
}
\end{lstlisting}

Сама структура `Q' содержит всю информацию, нужную для генерации определения отдельной декларации функции `infer' и `nf'. Так как весь код, который генерируется будет исполнятся внутри монады `TC (Either Left)', можно просто сгенерировать список выражений Haskell, а затем приписать сверху `do', и таким образом будет обеспечен порядок выполнения выражений.

Для создания свободных переменных Haskell используется простой счетчик, так как вероятность появления большого количества переменных внутри одной декларации мала. Эти переменные используются для хранения результатов предыдущих вычислений внутри функции.

В структуре `Q' существует таблица, где для каждой метапеременной написана переменная языка Haskell, которая ей соответствует в генерирующемся коде. Каждая метапеременная находится в контексте описанном в подразделе forall правила вывода/редукции. Это нужно для генерации всех других выражений специфицированного языка так, как описано в Разделе~\ref{build_exp}.

Поле `juds' нужно только при генерации функции `infer'. В нем хранятся предпосылки правила вывода конструкции трёх видов:
\begin{enumerate}
  \item Вводящие метапеременные --- меняют таблицу метапеременных. Соответствующую метапеременную, вводимую данным выражением, удобно хранить вместе с предпосылкой, в которой она вводится. Примером такой предпосылки является `$x : S \vdash t : T$', если метапеременная `$T$' не встречается в конструкции в заключении правила вывода.
  \item Имеющие какой-то тип у терма справа от `$\vdash$', а значит нужно ещё строит этот тип и проверять его на равенство выведенному. Тип, на равенство которому будет проводиться проверка, хранится рядом для удобства. Пример такой предпосылки: `$x : S \vdash tm : type$', где `$type$' какое-то выражение.
  \item Остальные --- предпосылки, которые просто нужно проверить на определенность. Примером такой предпосылки является `$x : S \vdash t\ def$'.
\end{enumerate}

Также в `Q' Хранится таблица всех метапеременных из подраздела forall и конструкций языка, так как в предпослыках вида `$\Gamma \vdash T\ def$' и `$\Gamma \vdash f(...)\ def$' нам нужно знать сорт метапеременной или сорт возвращаемый нашей конструкцией, чтобы вернуть его из функции `infer'.

Для простоты реализации использована библиотека lens\cite{lens}. Что позволяет писать функции выглядящие императивно в Haskell, например при манипуляции State во вставке~\ref{lst_imperative}.

\begin{lstlisting}[caption={Примеры ``императивного'' кода внутри монады State c использованием библиотеки lens},captionpos=b,frame=single, float, floatplacement=H, label={lst_imperative}]
appendStmt :: Stmt -> BldRM ()
-- Modify part of the State using a function
appendStmt st = doStmts %= (++ [st])

genCheckMetaEq :: BldRM ()
genCheckMetaEq = do
  ms <- gets _metas
  -- Replaces metas inside State Monad
  metas <~ sequence (genMetaEq <$> ms)
\end{lstlisting}

А именно: `\lstinline{doStmts %= (++ [st])}' --- позволяет менять состояние, как будто бы мы применили мутирующую функцию к глобальной переменной. А код `\lstinline{metas <~ sequence (genMetaEq <$> ms)}' выглядит так, будто мы просто присваиваем результат монадического вычисления в ``глобальную'' переменную metas.











%%%
