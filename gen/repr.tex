\subsection{Структура модуля генерации кода}\label{repr}
Генерация кода происходит внутри монады GenM, которая является стэком монад: \lstinline{ReaderT SymbolTable (StateT CodeGen (ErrorM))}.

\begin{lstlisting}[caption={Структура используемая при кодогенерации},captionpos=b,frame=single]
data CodeGen = Gen{
, decls :: [Decl]
}
\end{lstlisting}

Так как структура заполняемая модулем проверки спецификации не меняется на этапе кодогенерации, она находится внутри монады ReaderT. При кодогенерации происходит генерация деклараций языка Haskell, которые хранятся в виде списка, затем все эти декларации будут добавлены в модуль опредения языка.

Во всей программе происходит генерация определений четырех сущностей:
\begin{itemize}
\item Представления специфицированного языка
\item Представителя класса Monad для представления языка
\item Функции infer --- вывода типов терма
\item Функции nf --- приведения в нормальную форму/вычисления терма
\end{itemize}

Из описанных выше сущностей, не была описана генерация только последних двух (остальные описаны в Разделе~\ref{final_repr}).

Из-за того, что функции infer и nf определяются при помощи сопоставления с образцом конструкций языка (также нужно сопоставляться с образцом с переменными), и каждое сопоставление с образцом считается отдельной декларацией АСД Haskell, можно считать генерацию каждой декларации в некотором смысле отдельной задачей. А именно --- все переменные введенные внутри одной декларации могут быть переиспользованы внутри другой.

Поэтому для генерации каждой отдельной декларации функций infer и nf создается внутренная монада BldRM, которая определена как \lstinline{StateT Q (ErrorM)}.

\begin{lstlisting}[caption={Структура используемая при кодогенерации функций infer и nf},captionpos=b,frame=single]
data Q = Q {
  _count :: Int,
  _doStmts :: [Stmt],
  _metas :: Map.Map MetaVar [(Ctx, Exp)],
  -- These three, below are used for infer only
  _juds  :: Juds,
  _foralls :: Map.Map MetaVar Sort,
  _funsyms :: Map.Map AST.Name FunctionalSymbol
}

data Juds = Juds {
  _metaTyDefs :: [(MetaVar, Judgement)],
  _notDefsTy :: [(Term, Judgement)],
  _otherJuds :: [Judgement]
}
\end{lstlisting}

Сама структура `Q' содержит всю информацию, нужную для генерации определения отдельной декларации функции `infer' и `nf'. Так как весь код, который генерируется будет исполнятся внутри монады TC (Either Left), можно просто сгенерировать список выражений Haskell, а затем приписать сверху `do', и таким образом будет обеспечен порядок выполнения выражений.

Для создания свободных переменных Haskell используется простой счетчик, так как вероятность появления большого количества переменных внутри одной декларации мала. Эти переменные используются для хранения результатов предыдущих вычислений внутри функции.

В структуре `Q' существует таблица, где для каждой метапеременной написан терм языка Haskell, который ей соответствует в коде. Каждая метапеременная находится в контексте описанном в подразделе forall правила вывода/редукции. Это нужно для генерации всех других термов специфицированного языка так, как описано в Подразделе~\ref{build_exp}. 

juds нужна только при генерации функции `infer'. В ней хранятся предпосылки правила вывода конструкции трёх видов. Все предпосылки делятся на три вида:
\begin{enumerate}
  \item Вводящие метапеременные --- меняют таблицу метапеременных. Соответствующую метапеременную, вводимую данным выражением, удобно хранить вместе с предпосылкой, в которой она вводится. Например `$x : S \vdash t : T$', если $T$ не встречается в конструкции в заключении правила вывода.
  \item Имеющие какой-то у терма справа от `$\vdash$', а значит нужно ещё строит этот тип и проверять его на равенство выведенному. Терм, на равенство которому будет проводиться проверка, хранится рядом для удобства.
  \item Остальные --- предпосылки, которые просто нужно проверить на определенность.
\end{enumerate}

Это хранится в структуре Q в виде трёх списков предпосылок.

Хранится таблица всех метапеременных из подраздела forall и конструкций языка, так как в предпослыках вида \lstinline{...|- T def} и \lstinline{...|- f(...) def} нам нужно знать сорт метапеременной или сорт возвращаемый нашей конструкцией, чтобы вернуть его из функции `infer'.

Для простоты реализации использована библиотека lens\cite{lens}. Что позволяет писать следующие функции в Haskell, например при манипуляции State:

\begin{lstlisting}[frame=single]
appendStmt :: Stmt -> BldRM ()
-- Modify part of the State using a function
appendStmt st = doStmts %= (++ [st])

genCheckMetaEq :: BldRM ()
genCheckMetaEq = do
  ms <- gets _metas
  -- Replaces metas inside State Monad
  metas <~ sequence (genMetaEq <$> ms)
\end{lstlisting}

А именно: \lstinline{doStmts %= (++ [st])} --- позволяет менять состояние, как будто бы мы применили мутирующую функцию к глобальной переменной. А код \lstinline{metas <~ sequence (genMetaEq <$> ms)} выглядит так, будто мы просто присваиваем результат монадического вычисления в ``глобальную'' переменную metas.











%%%
